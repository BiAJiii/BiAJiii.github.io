---
title: 一些数据结构与算法
date: 2023-01-10 15:50:09
tags:
---
## 二叉树

![image-20230106145213189](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061452280.png)

* 存储方式：

![image-20230106150159499](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061501599.png)

### 二叉搜索树(BST)

![image-20230106150422377](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061504675.png)

![image-20230106151827638](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061518174.png)

* 封装实现:

> ```
> //二叉树封装
> function BST() {
>     //节点保存
>     function Node(key) {
>         this.key = key 
>         this.left = null
>         this.right = null
>     }
>     //根属性
>     this.root = null;
>     
>     BST.prototype.insert = function (key) {
>         let newNode = new Node(key)
>         //判断根是否存在
>         if(this.root === null){
>             this.root = newNode
>         } else {
>             this.NodeCompare(this.root, newNode)
>         }
>     }
> 
>     BST.prototype.NodeCompare = function (oldNode, newNode) {
>         //左查找
>         if(newNode.key < oldNode.key) {
>             if(oldNode.left !== null) {
>                 this.NodeCompare(oldNode.left, newNode)
>             } else {
>                 oldNode.left = newNode
>             }
>         //右查找    
>         } else if( newNode.key > oldNode.key ) {
>             if(oldNode.right !== null) {
>                 this.NodeCompare(oldNode.right, newNode)
>             } else {
>                 oldNode.right = newNode
>             }
>         } else {
>             alert('当前数值已存在')
>         }
>     }   
> }
> const bst = new BST()
> 
> ```

* 遍历方法：

1、先序遍历

![image-20230106160858807](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061608249.png)

> ```
> //先序遍历
> //handler用于处理遍历显示形式
> BST.prototype.preTravelsal = function(handler) {
>     this.preTravelsalNode(this.root, handler)
> }
> //节点遍历
> //递归调用栈（前进后出）
> BST.prototype.preTravelsalNode = function(Node, handler){
>     if(Node !== null){
>         handler(Node.key)//这个其实可以看做是当前处理的节点
>         //处理左子节点
>         this.preTravelsalNode(Node.left, handler)
>         //如果左子节点没有，处理右子节点
>         this.preTravelsalNode(Node.right, handler)
>     }
> }
> ```

测试代码：

> ```
> const bst = new BST()
> 
> bst.insert(3)
> bst.insert(1)
> bst.insert(4)
> bst.insert(0)
> bst.insert(2)
> 
> var result = ''
> bst.preTravelsal(function (key) {
>     result += key + '-'
> }) 
> console.log(result)
> //结果：3-1-0-2-4
> ```

2、中序遍历

![image-20230106171729924](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061717225.png)

> ```
> //先序遍历对调一下就好
> //处理左子节点
> this.preTravelsalNode(Node.left, handler)
> //处理该节点
> handler(Node.key)
> //处理右子节点
> this.preTravelsalNode(Node.right, handler)
> ```

3、后序遍历

![image-20230106171937295](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061720015.png)

> ```
> //同理
> //先序遍历对调一下就好
> //处理左子节点
> this.preTravelsalNode(Node.left, handler)
> //处理右子节点
> this.preTravelsalNode(Node.right, handler)
> //处理该节点
> handler(Node.key)
> 
> ```



* 删除节点

1、查找删除的节点，找到进行下一步，未找到就return

注意：最好添加几个变量，方便后续删除

parent（删除节点的父节点） current（要删除的节点） isLeft（删除节点的左侧是否存在）

2、找到节点分为以下几个情况

​	a、删除叶子点

​	一：isLeft：ture ，让parent.left = null

​	二：isLeft：false ，让parent.right = null

​	b、删除有一个节点的子节点

​	四种情况

​	parent.left = current.left

​	parent.left = current.right

​	parent.right = current.left

​	parent.right = current.right

​	c、删除的节点有两个节点

​	思路：该节点有左右两分支，其实有两种方案，如果选左边，则找到该节点左分支下最大的数字替代该节点。若选的为右边，则选择该节点右分支下最小的数字替代该节点。

## 排序算法

### 冒泡排序

```
ArrayList.prototype.BubbleSort = function () {
    let temp = null
    let arr = this.array
    for(let i = 0 ; i < arr.length ; i++){
        for(let j = 0; j < arr.length - i; j++){
            if(arr[j] > arr[j+1]){
                temp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = temp
            }
        }
    }
    console.log('冒泡后：' + arr)
}
```

冒泡排序效率：

![image-20230109141033549](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091410723.png)



### 选择排序

​	选择排序的实现思路是从未排序序列中找到最小的元素，放到已排序序列的首位，重复上述步骤，直到所有元素排序完毕。

1）假设未排序序列的第一个是最小值，记下该元素的位置，从前往后比较
2）若某个元素比该元素小，覆盖最小值的位置
3）重复第二个步骤，直到找到未排序的末尾
4）将未排序元素的第一个元素和最大元素交换位置
5）重复前面几个步骤，直到所有元素都已经排序。

```
 //选择排序
ArrayList.prototype.SelectSort = function () {
    let temp = null
    let arr = this.array
    let len = this.array.length
    for( let i = 0 ; i < len ; i++){
        let index = i
        for( let j = i+1; j < len; j++){
            if(arr[index] > arr[j]){
                index = j
            }
        }
        temp = arr[i]
        arr[i] = arr[index]
        arr[index] = temp

    }
    console.log('选择排序后：' + arr)
}
```

效率：

![image-20230109144042607](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091440704.png)

### 插入排序

![image-20230109161222605](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091612833.png)

```
ArrayList.prototype.InsertSort = function () {
    let Arr = this.array
    let len = this.array.length
    //因为每一次比较，标记index前的数组都被看做为一个整体，所以需要进行lenght-1次比较
    for( let i = 1; i < len ; i++){
        //j对应需要比较数字的索引
        //让j=i是为了不影响大循环中i
        let j = i
        //将需要比较数字记录为临时变量temp
        let temp = Arr[i]
        //由于插入比较是标记数字对前面的有序数组，进行从大到小的比较
        //所以，当temp小于有序数组中对应数字，循环仍要进行
        while(Arr[j-1] > temp){
            //由于temp小于该轮有序数组的数字，则要将该轮数字往后移，即index+1，且j--，进行下一轮比较
            Arr[j] = Arr[j-1]
            j--
            //当temp与有序数组中所有数字进行比较仍未满足跳出while循环条件，即temp为有序数组中最小的数，直接在j==0的位置插入
            if(j == 0){
                break;
            }
        }
        //将temp插入到找到索引对应的位置中
        Arr[j] = temp
    }
    console.log('插入排序：' + Arr)
}
```

效率：

![image-20230109161455585](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091614746.png)

 

### 希尔排序

​		希尔排序是通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。增量为：**gap=length/2**

原理图示（假设数组长度为8）：

（1）gap为4

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091703499.png)

（2）gap为2

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091704200.png)

（3）gap为1

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091704566.png)

其实希尔排序是基于插入排序的，只不过是希尔排序按间隔进行了分组

```
//希尔排序
    ArrayList.prototype.ShellSort = function() {
        let len = this.array.length
        let arr = this.array
        let gap = Math.floor(len/2)
        while(gap >= 1) {
            //类似插入算法那一套，但现在间隔变成了gap而不是1
            for( let i = gap; i < len; i++) {
                let j = i
                let temp = arr[j]
                while(arr[j - gap] > temp && j >= gap) {
                    arr[j] = arr[j-gap]
                    j -= gap
                }
                arr[j] = temp
            }
            gap = Math.floor(gap / 2)
        }
        console.log('希尔排序：' + arr)
    }
```

效率：

![image-20230109171009853](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091710987.png)



### 快速排序

![image-20230109171448025](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091714254.png)

基本思想：

1、选定pivot中心轴

2、将大于pivot的数字放在piovt右边

3、将小于pivot的数字放在piovt右边

4、分别对左右子序列重复前前三步操作（递归）

5、当递归尽头的左右子序列长度都为1时，跳出递归

> ```
> //快速排序
> ArrayList.prototype.QuickSort = function (L ,R) {
>     // L和R是为了确定一开始左和右的数如：（0，8），而left和right会随着循环变化，
>     // 如果不设定L和R，会导致栈溢出
>     // 在递归过程中，right和left是不断变化的，而L和R会保持一开始输入的数字
>     let arr = this.array
>     let left = L
>     let right = R
>     //将数组最右边的设为piovt
>     //先左指针循环，再右指针循环
>     //如果pivot为最左边
>     //则右指针先循环，左指针再循环
>     let pivot = arr[right]
>     if(left >= right) {
>         return
>     }
>     while(left < right) {
>         //左指针向右遍历，遇到比pivot大的数停止
>         while(left < right && arr[left] <= pivot){
>             left++
>         }
>         if(arr[left] > pivot){
>             arr[right] = arr[left]
>         }
>         //左指针向左遍历，遇到比pivot小的数停止
>         while(left < right && pivot <= arr[right]){
>             right--
>         }
>         if(arr[right] < pivot){
>             arr[left] = arr[right]
>         }
>         if(left >= right){
>             arr[left] = pivot
>         }
>     }
>     //pivot左边递归
>     this.QuickSort(L , left-1)
>     //pivot右边递归
>     this.QuickSort(left+1 ,R)
> }
> ```

![image-20230110152931858](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301101529051.png)

* X表示该数字放进了最右边的位置