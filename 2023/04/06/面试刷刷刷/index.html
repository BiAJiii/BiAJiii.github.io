<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="面试刷刷刷JS、TS、ES61、传值和传址基础数据类型是传值：存放在栈中（字符串、数字等） 复杂数据类型是传址：存放在堆中，指向栈（对象、函数等） 2、判断数据类型1、typeof 主要用来判断基本数据类型 2、instanceof：数组+ instanceof + 构造原型 返回布尔值 3、object.prototype.toString.call()   会直接生产[object 输入数据的">
<meta property="og:type" content="article">
<meta property="og:title" content="Samuel&#39;s Blog">
<meta property="og:url" content="http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/index.html">
<meta property="og:site_name" content="Samuel&#39;s Blog">
<meta property="og:description" content="面试刷刷刷JS、TS、ES61、传值和传址基础数据类型是传值：存放在栈中（字符串、数字等） 复杂数据类型是传址：存放在堆中，指向栈（对象、函数等） 2、判断数据类型1、typeof 主要用来判断基本数据类型 2、instanceof：数组+ instanceof + 构造原型 返回布尔值 3、object.prototype.toString.call()   会直接生产[object 输入数据的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092145519.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092147863.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251631095.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111345497.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251724816.png">
<meta property="og:image" content="c:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230313225724386.png">
<meta property="og:image" content="c:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230313225731329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251406374.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303222258109.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303241106254.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202145313.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202148573.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202200254.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111708141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303231547636.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111712276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111826919.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111827410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251347564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251347247.png">
<meta property="og:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251430018.jpeg">
<meta property="article:published_time" content="2023-04-06T15:19:07.547Z">
<meta property="article:modified_time" content="2023-04-06T15:24:32.035Z">
<meta property="article:author" content="Samuel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092145519.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Samuel&#39;s Blog</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/BiAJiii">Projects</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/04/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/01/13/LeetCode-Updating/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&text="><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&is_video=false&description="><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&name=&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&t="><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7"><span class="toc-number">1.</span> <span class="toc-text">面试刷刷刷</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E3%80%81TS%E3%80%81ES6"><span class="toc-number">2.</span> <span class="toc-text">JS、TS、ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">1、传值和传址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2、判断数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81slice%E3%80%81split%E3%80%81splice"><span class="toc-number">2.3.</span> <span class="toc-text">3、slice、split、splice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4、数组遍历方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.5.</span> <span class="toc-text">5、深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81this"><span class="toc-number">2.6.</span> <span class="toc-text">6、this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%94%B9%E5%8F%98this%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">7、改变this的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81new%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">8、new的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.9.</span> <span class="toc-text">9、异步解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BEprototpye-x2F-proto"><span class="toc-number">2.10.</span> <span class="toc-text">10、原型链prototpye&#x2F;_proto_</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-number">2.11.</span> <span class="toc-text">11、闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">2.12.</span> <span class="toc-text">12、防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81nextTick"><span class="toc-number">2.13.</span> <span class="toc-text">13、nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.14.</span> <span class="toc-text">14、JS运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.15.</span> <span class="toc-text">15、块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.16.</span> <span class="toc-text">16、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81var%E3%80%81let%E3%80%81const"><span class="toc-number">2.17.</span> <span class="toc-text">17、var、let、const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.18.</span> <span class="toc-text">18、JS垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81EventLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.19.</span> <span class="toc-text">19、EventLoop 事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81setTimeout%E3%80%81Promise%E3%80%81Async-x2F-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">20、setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.21.</span> <span class="toc-text">21、图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">2.22.</span> <span class="toc-text">22、DOM事件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.23.</span> <span class="toc-text">23、事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81-Object%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">2.24.</span> <span class="toc-text">24、 Object构造函数上语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81Dom%E6%93%8D%E4%BD%9C"><span class="toc-number">2.25.</span> <span class="toc-text">25、Dom操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">3.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1、三次握手、四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81TCP%E5%92%8CUDP"><span class="toc-number">3.2.</span> <span class="toc-text">2、TCP和UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81HTTP%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.</span> <span class="toc-text">3、HTTP跨域请求解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4、输入URL到加载页面的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.5.</span> <span class="toc-text">5、常见状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81get%E5%92%8Cpost%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">6、get和post有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">3.7.</span> <span class="toc-text">7、异步请求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML%E3%80%81CSS"><span class="toc-number">4.</span> <span class="toc-text">HTML、CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">1、HTML语义化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CSS%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2、CSS选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81position%E5%B1%9E%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">3、position属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81box-sizing%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">4、box-sizing属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">5、CSS盒子模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81BFC"><span class="toc-number">4.6.</span> <span class="toc-text">6、BFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%B1%85%E4%B8%AD"><span class="toc-number">4.7.</span> <span class="toc-text">7、居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%9F%90%E5%85%83%E7%B4%A0"><span class="toc-number">4.8.</span> <span class="toc-text">8、隐藏页面中某元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="toc-number">4.9.</span> <span class="toc-text">9、页面布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">4.10.</span> <span class="toc-text">10、重排和重绘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">5.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81SPA%E5%92%8CMVC%E5%92%8CMVVM"><span class="toc-number">5.1.</span> <span class="toc-text">1、SPA和MVC和MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81vue2-x2F-3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2、vue2&#x2F;3生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81watch%E5%92%8Ccomputed"><span class="toc-number">5.3.</span> <span class="toc-text">3、watch和computed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81router%E3%80%81routes%E5%92%8Croute"><span class="toc-number">5.4.</span> <span class="toc-text">4、router、routes和route</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81v-if%E5%92%8Cv-show"><span class="toc-number">5.5.</span> <span class="toc-text">5、v-if和v-show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82"><span class="toc-number">5.6.</span> <span class="toc-text">6、vue组件传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Vue%E9%A1%B9%E7%9B%AE%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.7.</span> <span class="toc-text">7、Vue项目中key的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Vuex"><span class="toc-number">5.8.</span> <span class="toc-text">8、Vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Diff%E7%AE%97%E6%B3%95"><span class="toc-number">5.9.</span> <span class="toc-text">9、Diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.10.</span> <span class="toc-text">10、常用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81ref%E5%92%8Creactive%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">11、ref和reactive区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack"><span class="toc-number">6.</span> <span class="toc-text">Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="toc-number">6.1.</span> <span class="toc-text">1、优化 Webpack 的构建速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF"><span class="toc-number">6.2.</span> <span class="toc-text">2、优化 Webpack 的打包体积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">3、webpack构建流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Babel"><span class="toc-number">7.</span> <span class="toc-text">Babel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Babel%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">1、Babel编译过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git"><span class="toc-number">8.</span> <span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.</span> <span class="toc-text">1、基本指令</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Samuel</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-06T15:19:07.547Z" itemprop="datePublished">2023-04-06</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="面试刷刷刷"><a href="#面试刷刷刷" class="headerlink" title="面试刷刷刷"></a>面试刷刷刷</h1><h1 id="JS、TS、ES6"><a href="#JS、TS、ES6" class="headerlink" title="JS、TS、ES6"></a>JS、TS、ES6</h1><h2 id="1、传值和传址"><a href="#1、传值和传址" class="headerlink" title="1、传值和传址"></a>1、传值和传址</h2><p>基础数据类型是传值：存放在栈中（字符串、数字等）</p>
<p>复杂数据类型是传址：存放在堆中，指向栈（对象、函数等）</p>
<h2 id="2、判断数据类型"><a href="#2、判断数据类型" class="headerlink" title="2、判断数据类型"></a>2、判断数据类型</h2><p>1、typeof 主要用来判断基本数据类型</p>
<p>2、instanceof：数组+ instanceof + 构造原型 返回布尔值</p>
<p>3、object.prototype.toString.call()   会直接生产[object 输入数据的数据类型]</p>
<h2 id="3、slice、split、splice"><a href="#3、slice、split、splice" class="headerlink" title="3、slice、split、splice"></a>3、slice、split、splice</h2><ul>
<li>splice：从数组中添加或删除元素，返回新的数组(⚠️：会对原数组进行更改，获取的是新的数组)</li>
</ul>
<p>添加：splice(index，0，data1，data2，……);	index:插入的元素的起始位置；0：删除的个数为0；data1，data2：添加的元素；</p>
<p>删除：splice(index,0);	index:删除数组的起始位置；0：删除元素的个数；</p>
<ul>
<li>slice：用于截取数组，并返回截取到的新的数组，数组与字符串对象都使用(⚠️：对原数组不会改变)</li>
</ul>
<p>语法：arr.slice(start,end)  左闭右开</p>
<ul>
<li>split：切割字符串，将字符串转化为字符串数组</li>
</ul>
<p>根据a.split(‘’)中传入的符号，对字符串进行分割并下放入数组。</p>
<h2 id="4、数组遍历方法"><a href="#4、数组遍历方法" class="headerlink" title="4、数组遍历方法"></a>4、数组遍历方法</h2><p>1、foreach</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092145519.png" alt="img"></p>
<p>2、map</p>
<p><strong>map即是 “映射”的意思 ，原数组被“映射”成对应新数组</strong><br><strong>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<br>map() 不会改变原始数组。<br>map() 不会对空数组进行检测。</strong><br><strong>map支持return</strong></p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092147863.png" alt="img"></p>
<p>map和forEach区别</p>
<ol>
<li>forEach()和map()方法通常用于遍历Array元素</li>
<li>forEach：总是返回undefined；用来遍历数组中的每一项，不影响原数组，只是对数组每一项进行一次操作，并不能修改</li>
<li>map：返回一个包含已转换元素的新数组；支持return，相当于与原数组克隆了一份，把克隆的每项改变了，也不影响原数组</li>
</ol>
<p>3、filter</p>
<p>filter用于对数组进行过滤。<br>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>filter() 不会对空数组进行检测；不会改变原始数组</p>
<p><code>array.filter(function(currentValue,index,arr), thisValue)</code></p>
<p>4、for..of</p>
<p>for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。但是for of也有一个致命伤，没有索引。对，这是优点也是缺点。遍历数组对象，直接就是item.属性(或者item[属性]),而不用像for循环那样arr[index].属性(arrindex)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let item of arr)&#123;</span><br><span class="line">    console.log(item);    //item指的的就是数组每一项的值。不是索引。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5、for…in</p>
<p>for in循环是用来遍历对象的。要知道JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。（注意：遍历时不仅能读取对象自身上面的成员属性，也能遍历出对象的原型属性）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;a:1, b:2, c:3&#125;;</span><br><span class="line">for (let prop in obj) &#123;    //prop指对象的属性名</span><br><span class="line">console.log(prop, obj[prop]);</span><br><span class="line">&#125;</span><br><span class="line">// 输出:</span><br><span class="line">// a,1</span><br><span class="line">// b,2</span><br><span class="line">// c,3</span><br></pre></td></tr></table></figure>



<p>6、find方法</p>
<ul>
<li><strong>遍历数组，找到第一个符合条件的项，并返回该项；不会继续遍历数组；否则返回undefined</strong></li>
<li><strong>不会改变数组</strong></li>
</ul>
<p><code>[1,4,-5,10].find((n) =&gt; n &lt; 0 ) </code></p>
<p>7、findindex方法</p>
<ul>
<li><strong>遍历数组找到第一个符合条件的项，并返回该项的索引值；不会继续遍历数组；否则返回-1。</strong></li>
<li><strong>不会改变数组</strong></li>
</ul>
<p>同上，只不过返回的是索引</p>
<p>9、some方法</p>
<p><strong>1）如果<code>有一个元素满足条件</code>，则表达式返回<code>true</code>，剩余的元素不会再执行检测。</strong><br><strong>2）如果没有满足条件的元素，则返回false。</strong><br><strong>3）返回值是布尔值</strong></p>
<p>注：</p>
<p><strong>1) some() 不会对空数组进行检测。</strong><br><strong>2) some() 不会改变原始数组。</strong></p>
<p>10、every方法</p>
<p><strong>1）如果数组中有一个元素不满足，则整个表达式返回false；且剩余的元素不会再进行检测</strong><br><strong>2）如果<code>所有元素都满足条件</code>，则返回<code>true</code>。</strong><br><strong>3）返回值是布尔值</strong></p>
<p>10、reduce方法</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251631095.png" alt="image-20230325163135999"></p>
<p>total为上次调用返回的值或者初始值，每循环一次，结果都会迭代掉total，变成新的total。</p>
<p><strong>1）接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</strong><br><strong>2）第二个参数作为第一次调用的a的值</strong></p>
<h2 id="5、深拷贝和浅拷贝"><a href="#5、深拷贝和浅拷贝" class="headerlink" title="5、深拷贝和浅拷贝"></a>5、深拷贝和浅拷贝</h2><p>浅拷贝：复杂数据类型的地址</p>
<p>深拷贝：完全赋值一份数据一样的非同一地址的数据</p>
<h2 id="6、this"><a href="#6、this" class="headerlink" title="6、this"></a>6、this</h2><p>this指的是当前代码执行的上下文</p>
<p>顶层全局作用域为window</p>
<p>声明的全局变量挂在在window上</p>
<p>普通函数的this是执行时绑定，箭头函数是声明时绑定this（声明时的作用域的this）；比如在windows声明了对象A，对象A中不管嵌套了多少层，再打印this，这个this都是指向声明A时作用域下的this，即window</p>
<h2 id="7、改变this的方法"><a href="#7、改变this的方法" class="headerlink" title="7、改变this的方法"></a>7、改变this的方法</h2><p>1、 call 改名this指向并立即执行函数，参数逗号分隔</p>
<p>2、apply 改名this指向并立即执行函数，参数以数组形式写</p>
<p>3、bind 语法和call相同，但改变完不会立即执行，需要在后面再加个小括号才执行</p>
<h2 id="8、new的过程"><a href="#8、new的过程" class="headerlink" title="8、new的过程"></a>8、new的过程</h2><p><code>let obj = new Object()</code></p>
<ol>
<li>首先创建了一个新的<code>空对象</code></li>
<li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。（继承原型链）</li>
<li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（构造函数继承）</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<p>如果没有return或者return的是简单数据类型，则忽略；直接进行return this</p>
<p>如果return的是复杂数据类型，则返回的就是当前return的值</p>
<h2 id="9、异步解决方案"><a href="#9、异步解决方案" class="headerlink" title="9、异步解决方案"></a>9、异步解决方案</h2><p>1、callback回调函数（将回调函数以传参的方式先传给函数，等到时机成熟，函数再去调用回调函数）</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function get(callback)&#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    callback(&quot;你好&quot;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get((res) =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2、promise函数</p>
<p>promise函数有三种状态：pending &#x3D;&gt; 转为另外两种状态resolve&#x2F;reject</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function p1(param) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;成功&quot;)</span><br><span class="line">    reject(&quot;失败&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>promise.all：多个异步任务执行完进行操作</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//参数为promise对象组成的数组，then必须全resolve</span><br><span class="line">promise.all([p_1(),p_2(),p_3()]).then(res =&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">	//返回最近的一个错误</span><br><span class="line">	...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3、asycn_await</p>
<p>async可以单独使用，且返回的是promise对象</p>
<p>await（后跟异步或promise）必须配合async使用</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f3(params) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&quot;成！&quot;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function f3_await() &#123;</span><br><span class="line">  let res = await f3()</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;</span><br><span class="line">//不用async的话，调用f3_await也只是在pending状态</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="10、原型链prototpye-x2F-proto"><a href="#10、原型链prototpye-x2F-proto" class="headerlink" title="10、原型链prototpye&#x2F;_proto_"></a>10、原型链prototpye&#x2F;_<em>proto</em>_</h2><p>prototype：只有函数对象才有，即（构造）函数原型对象，会返回一个对象 </p>
<p>__proto__：所有对象都有此属性，总是指向该对象对应的构造函数的原型对象</p>
<p>constructor：__proto__下面的constructor指向构造函数自己（用于判断对象的原型是否为某个对象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象.__proto__ === 对象的构造函数.prototype  // true</span><br><span class="line">对象.__proto__.__proto__ === 对象的构造函数.prototype.__proto__  // true</span><br><span class="line">对象.__proto__.constructor==对象的构造函数</span><br></pre></td></tr></table></figure>



<ul>
<li><p>原型链终点：Object.prototype</p>
</li>
<li><p>对象访问属性时，先在自身属性查找，找不到再去__proto__的原型链上查找，直到找不到为止会返回undefined</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111345497.png" alt="image-20230311134532149"></p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251724816.png" alt="img"></p>
<h2 id="11、闭包"><a href="#11、闭包" class="headerlink" title="11、闭包"></a>11、闭包</h2><p>如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。</p>
<p>闭包：函数套函数，并把内部函数return，内部函数可以访问外部函数的变量，一级级向上找；是内部函数访问父函数的变量的结果（内部函数引用外部函数的局部变量，延长外部函数的变量生命周期）</p>
<p>特点：</p>
<p> 让外部访问函数内部变量成为可能；</p>
<p> 局部变量会常驻在内存中；</p>
<p> 可以避免使用全局变量，防止全局变量污染；</p>
<p> 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p>
<p>作用：封装变量，收敛权限</p>
<p>优点：不会造成全局变量污染</p>
<p>内存：垃圾回收机制：当一个变量在作用域内部不再被使用，会被内存释放（使用闭包不会被垃圾回收机制回收，可能造成内存泄漏）</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">   var num=3;</span><br><span class="line">   return function()&#123;</span><br><span class="line">      var n=0;</span><br><span class="line">      console.log(++n);</span><br><span class="line">      console.log(++num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fn1=fn();</span><br><span class="line">fn1();//n=1;num=4</span><br><span class="line">fn1();//n=1;num=5</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​		一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，这时候相当于fn1&#x3D;function(){var n &#x3D; 0 … }，并且匿名函数内部引用着fn里的变量num，所以变量num无法被销毁，而变量n是每次被调用时新创建的，所以每次fn1执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的num，于是这里就产生了内存消耗的问题。</p>
<h2 id="12、防抖和节流"><a href="#12、防抖和节流" class="headerlink" title="12、防抖和节流"></a>12、防抖和节流</h2><p>防抖：用户一直触发某个函数，触发时间间隔如果小于设定的时间间隔，则只执行一次</p>
<p>节流：在设定之间间隔内执行一次</p>
<p>区别：防抖和节流本质是不一样的。防抖是将多次执行变为最后一次执行（停下后的最后一次才执行），节流是将多次执行变成每隔一段事件执行（会执行，且按照时间间隔执行）</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//防抖，如果有继续点击，就清除定时器</span><br><span class="line">let a = document.createElement(&quot;input&quot;)</span><br><span class="line">a.type = &quot;button&quot;</span><br><span class="line">a.value = &quot;点一下&quot;</span><br><span class="line">document.body.appendChild(a)</span><br><span class="line"></span><br><span class="line">function debounce(fn ,delay)&#123;</span><br><span class="line">  let time = null</span><br><span class="line">  return function()&#123;</span><br><span class="line">    clearTimeout(time)</span><br><span class="line">    time = setTimeout(()=&gt;&#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;,delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function btn1() &#123;</span><br><span class="line">  console.log(&#x27;点一下&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.onclick = debounce(btn1, 500)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//节流</span><br><span class="line">let a = document.createElement(&quot;input&quot;)</span><br><span class="line">a.type = &quot;button&quot;</span><br><span class="line">a.value = &quot;点一下&quot;</span><br><span class="line">document.body.appendChild(a)</span><br><span class="line">function debounce(fn ,delay)&#123;</span><br><span class="line">  let lastTime = 0</span><br><span class="line">  return function()&#123;</span><br><span class="line">    let nowTime = new Date().getTime()</span><br><span class="line">    if(nowTime - lastTime &gt; delay)&#123;</span><br><span class="line">      btn1()</span><br><span class="line">      lastTime = nowTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function btn1() &#123;</span><br><span class="line">  console.log(&#x27;点一下&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.onclick = debounce(btn1, 1000)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="13、nextTick"><a href="#13、nextTick" class="headerlink" title="13、nextTick"></a>13、nextTick</h2><p>定义：下一次Dom更新结束后的回调函数，（最近一次数据渲染或更新后执行）</p>
<p>nextTick 就是设置一个回调，用于异步执行。就是把你设置的回调放在 setTimeout 中执行，这样就算异步了，等待当时同步代码执行完毕再执行。</p>
<h2 id="14、JS运行机制"><a href="#14、JS运行机制" class="headerlink" title="14、JS运行机制"></a>14、JS运行机制</h2><p>JS 执⾏是单线程的， 它是基于事件循环的。 事件循环⼤致分为以下⼏个步骤：<br>（1） 所有同步任务都在主线程上执⾏， 形成⼀个执⾏栈（execution context stack） 。<br>（2） 主线程之外， 还存在⼀个”任务队列”（task queue） 。 只要异步任务有了运⾏结果， 就在”任务队列”之中放置⼀个事件。<br>（3） ⼀旦”执⾏栈”中的所有同步任务执⾏完毕， 系统就会读取”任务队列”， 看看⾥⾯有哪些事件。 那些对应的异步任务， 于是结束等待状态， 进⼊执⾏栈， 开始执⾏。<br>（4） 主线程不断重复上⾯的第三步。</p>
<h2 id="15、块级作用域"><a href="#15、块级作用域" class="headerlink" title="15、块级作用域"></a>15、块级作用域</h2><p>​	JS 中，有三种作用域，分别为：全局作用域、函数作用域、块级作用域。<br>当执行一个项目或一个文件时，会先生成全局作用域；在执行每一个函数时，会生成对应的函数作用域；这两个作用域都是 JS 设计之初就有的，而块级作用域则是 ES6 才实现的。</p>
<p>正常情况下，JS 引擎在编译代码阶段会生成全局执行上下文和函数执行上下文。这其中，每个上下文又分为了两个部分：变量环境和词法环境。</p>
<p><img src="C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230313225724386.png" alt="image-20230313225724386"></p>
<p><img src="C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230313225731329.png" alt="image-20230313225731329"></p>
<ol>
<li>使用 var 关键字声明的变量、及函数声明，会被放入变量环境中</li>
<li>使用 let 及 const 关键字声明的变量和常量会被放入词法环境中</li>
<li>词法环境内部也类似于一个栈结构，每一个块结构(即有一对大括号，如条件句、循环等)内的变量和常量会单独保存(使用 var 关键字声明的不会)。</li>
<li>所以，如上面的例子，函数 foo 的词法环境里，有两个区域。下面的区域保存了函数体内使用 let 声明的变量，上面的区域保存了 if 语句中使用 let 声明的变量。所以即使它们都叫做 b，但却是两个不同的变量。</li>
</ol>
<p>如此一来，ES6 就通过执行上下文中的词法环境实现了块级作用域。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cdf85625450a">https://www.jianshu.com/p/cdf85625450a</a></p>
<h2 id="16、数据类型"><a href="#16、数据类型" class="headerlink" title="16、数据类型"></a>16、数据类型</h2><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)</p>
<p><strong>基本类型(值类型)：</strong> Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中</p>
<p><strong>引用类型(复杂数据类型)：</strong> Object(对象)、Function(函数)。其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</p>
<h2 id="17、var、let、const"><a href="#17、var、let、const" class="headerlink" title="17、var、let、const"></a>17、var、let、const</h2><p>const 基本类型不可修改，对象类型可以修改（const不可以修改栈里的地址，但可以修改堆里的数据）</p>
<p>let的暂时性死区（先定义再使用，拒绝变量提升）</p>
<p>区别：</p>
<p>1、var定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。<br> let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br> const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</p>
<p>2、var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</p>
<p>3、var是允许在相同作用域内<code>重复声明同一个变量</code>的，而let与const不允许这一现象。</p>
<p>4、在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;<br> var声明的变量会和GO有映射关系；</p>
<p>5、<code>会产生暂时性死区</code>： 检测未申明变量时，不会报错，而是返回undefined</p>
<h2 id="18、JS垃圾回收机制"><a href="#18、JS垃圾回收机制" class="headerlink" title="18、JS垃圾回收机制"></a>18、JS垃圾回收机制</h2><p>​		项目中，如果存在大量不被释放的内存（堆&#x2F;栈&#x2F;上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</p>
<p>原理：浏览器的<code>Javascript</code>具有自动垃圾回收机制(<code>GC:Garbage Collecation</code>)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<p><strong>优化手段</strong>：内存优化 ; 手动释放：取消内存的占用即可。</p>
<p>（1）堆内存：fn &#x3D; null 【null：空指针对象】</p>
<p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p>
<p><strong>内存泄漏</strong>：在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p>
<h2 id="19、EventLoop-事件循环"><a href="#19、EventLoop-事件循环" class="headerlink" title="19、EventLoop 事件循环"></a>19、EventLoop 事件循环</h2><p>​		JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为<strong>宏任务</strong>队列和<strong>微任务</strong>队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，Promise.then，MutationObserver，宏任务的话就是setImmediate setTimeout setInterval</p>
<ul>
<li>浏览器中的事件环(event loop)</li>
</ul>
<p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p>
<p>事件循环可以简单的描述为以下四个步骤:</p>
<ol>
<li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li>
<li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li>
<li>执行栈为空时，Event Loop把微任务队列执行清空；</li>
<li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li>
</ol>
<p><strong>任务源(task):</strong></p>
<ul>
<li><code>宏任务(macrotask)</code>（不需要立即连贯执行）：<br> 宿主环境提供的，比如浏览器<br> ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</li>
<li><code>微任务(microtask)</code>（需要立即连贯执行）：<br> 语言本身提供的，比如promise.then<br> then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251406374.png" alt="image-20230325140635272"></p>
<ul>
<li>Node环境的事件环</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303222258109.webp" alt="2020120317343116.png"></p>
<ul>
<li><code>timers</code>: 计时器，执行setTimeout和setInterval的回调</li>
<li><code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I&#x2F;O 回调</li>
<li><code>idle, prepare</code>: 队列的移动，仅系统内部使用</li>
<li><code>poll轮询</code>: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li>
<li><code>check</code>: 执行<code>setImmediate</code>回调，setImmediate在这里执行</li>
<li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<h2 id="20、setTimeout、Promise、Async-x2F-Await-的区别"><a href="#20、setTimeout、Promise、Async-x2F-Await-的区别" class="headerlink" title="20、setTimeout、Promise、Async&#x2F;Await 的区别"></a>20、setTimeout、Promise、Async&#x2F;Await 的区别</h2><p>1、setTimeout</p>
<p>settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p>
<p>2、Promise</p>
<p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行。</p>
<p>3、async&#x2F;await</p>
<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p>async&#x2F;await通过同步实现异步方法</p>
<p>Async&#x2F;Await就是一个<strong>自执行</strong>的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象.</p>
<h2 id="21、图片懒加载"><a href="#21、图片懒加载" class="headerlink" title="21、图片懒加载"></a>21、图片懒加载</h2><p>好处：减少HTTP请求，加快网页响应速度，减少服务器压力，增加用户浏览体验</p>
<p>原理：</p>
<p>1、监控滚动条滚动</p>
<p>2、获取总可视内容高度（可见视口高度+滚动条滚动高度）</p>
<p>3、获取所有图片</p>
<p>4、遍历步骤3（或这说：遍历伪数组）</p>
<p>5、在步骤4中判断，图片.offsetTop &lt;&#x3D; 步骤2 true-修改src属性为data-src、false-不管</p>
<p>6、 节流防抖优化</p>
<h2 id="22、DOM事件流"><a href="#22、DOM事件流" class="headerlink" title="22、DOM事件流"></a>22、DOM事件流</h2><p>捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；<br>目标阶段：真正的目标节点正在处理事件的阶段；<br>冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段。</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303241106254.png" alt="img"></p>
<h2 id="23、事件委托"><a href="#23、事件委托" class="headerlink" title="23、事件委托"></a>23、事件委托</h2><p>概念：事件委托也称为事件代理。就是利用事件冒泡，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p>
<p>事件委托的好处：</p>
<ul>
<li><p>利用冒泡的原理，将事件加到父级身上，这样只在内存中开辟一块空间，既节省资源又减少DOM操作，提高性能</p>
</li>
<li><p>可以为动态添加的元素绑定事件</p>
</li>
</ul>
<h2 id="24、-Object构造函数上语法"><a href="#24、-Object构造函数上语法" class="headerlink" title="24、 Object构造函数上语法"></a>24、 Object构造函数上语法</h2><p>重要</p>
<p>Object.defineProperty() vue双向绑定原理<br>Object.keys() 获取对象的所有键 返回数组<br>Object.values() 获取对象的所有值 返回数据<br>Object.create() 创建对象（特色 基于指定原型造对象 场景1：new原理优化，场景2：vue ）<br>Object.assign() 合并对象<br>Object.prototype.constructor 所属构造函数<br>Object.prototype.toString() 转字符串</p>
<h2 id="25、Dom操作"><a href="#25、Dom操作" class="headerlink" title="25、Dom操作"></a>25、Dom操作</h2><ul>
<li><p>获取：<br>getElementById() 通过id获取dom节点<br>getElementByTagName() 通过标签名获取dom节点<br>getElementByClassName() 通过类名获取dom节点<br>querySelector() 通过css选择器获取第一个符合的dom节点<br>querySelectorAll() 通过css选择器获取所有符合的dom节点，结果是一个伪数组</p>
</li>
<li><p>操作：<br>el.getAttribute() 获取el的属性<br>el.setAttribute() 设置el的属性<br>el.removeAttribute() 删除el的属性<br>元素节点上有一个dataset，里面包含了所有的H5自定义属性<br>el.dataset.属性名 获取H5自定义属性值<br>el.dataset.属性名 &#x3D; “值” 设值<br>delete el.dataset.属性名 删除<br>el.innerHTML 元素的可读写属性，里面的HTML代码可以被解析<br>el.innerText 元素的文本内容，里面的HTML代码打印出来是字符串<br>el.value 用于操作表单元素的内容</p>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、三次握手、四次挥手"><a href="#1、三次握手、四次挥手" class="headerlink" title="1、三次握手、四次挥手"></a>1、三次握手、四次挥手</h2><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202145313.png"></p>
<p>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack&#x3D;j+1），<code>同时也发送一个自己的SYN包</code>（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p><strong>SYN：用于建立连接。</strong> <strong>ACK：用于确定收到了请求。</strong> <strong>seq：发送自己的数据。</strong> <strong>FIN表示关闭连接</strong></p>
<p><strong>ack：发送接收到的对方的数据</strong></p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202148573.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202200254.png" alt="img"></p>
<p>四次挥手原理：</p>
<p>第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；</p>
<p>第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；</p>
<p>第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；</p>
<p>第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。</p>
<p>其中：FIN标志位数置1，表示断开TCP连接。</p>
<h2 id="2、TCP和UDP"><a href="#2、TCP和UDP" class="headerlink" title="2、TCP和UDP"></a>2、TCP和UDP</h2><p>1、TCP是面向<code>连接</code>的，而UDP是面向报文的。</p>
<p>2、TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p>
<p>3、TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p>
<p>4、UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p>
<h2 id="3、HTTP跨域请求解决方案"><a href="#3、HTTP跨域请求解决方案" class="headerlink" title="3、HTTP跨域请求解决方案"></a>3、HTTP跨域请求解决方案</h2><ul>
<li>原理：</li>
</ul>
<p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p>
<ul>
<li>解决方法</li>
</ul>
<p><strong>1、JSONP</strong></p>
<p>方法：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端。</p>
<p>步骤：</p>
<ol>
<li>去创建一个script标签</li>
<li>script的src属性设置接口地址</li>
<li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<p>缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>
<p><strong>2、CORS</strong> </p>
<p>CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p>
<p><strong>3、Proxy代理</strong></p>
<p>代理就是，比如你通过域A访问域B，那么在域A中架设一台代理服务器，把请求转发到域B，然后浏览器访问域A即可，这其中不涉及到跨域访问了。</p>
<p>前端后端分离开发时经常会用到这个特性，在本地架设一个代理服务器，以免浏览器无法跨域访问api。</p>
<p>例如：有一个天气预报页面<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.a.com">http://www.a.com</a>，需要向<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.weather.com">http://www.weather.com</a>接口获取天气数据，但是这个接口不支持JSONP和CORS跨域，那么可以这样做：</p>
<ol>
<li>搭建服务器，创建一个获取天气的接口<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.b.com">http://www.b.com</a></li>
<li>设置接口<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.b.com">http://www.b.com</a>的响应头<code>Access-Control-Allow-Origin:http://www.a.com</code></li>
<li>页面<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.a.com">http://www.a.com</a>向<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.b.com">http://www.b.com</a>发请求</li>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.b.com">http://www.b.com</a>收到请求后，向<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.weather.com">http://www.weather.com</a>获取天气数据，然后将天气数据返回给<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.a.com">http://www.a.com</a></li>
</ol>
<h2 id="4、输入URL到加载页面的过程"><a href="#4、输入URL到加载页面的过程" class="headerlink" title="4、输入URL到加载页面的过程"></a>4、输入URL到加载页面的过程</h2><p>1、URL解析：判断浏览器输入的是搜索内容还是URL；</p>
<p>2、查找缓存：如果能找到缓存则直接返回页面，如果没有缓存则需要发送网络请求页面；</p>
<p>3、DNS域名解析；</p>
<p>4、三次握手建立TCP连接；</p>
<p>5、发起HTTP请求；</p>
<p>6、服务器响应并返回结果；</p>
<p>7、通过四次握手释放TCP连接；</p>
<p>8、浏览器渲染；</p>
<p>9、js引擎解析</p>
<h2 id="5、常见状态码"><a href="#5、常见状态码" class="headerlink" title="5、常见状态码"></a>5、常见状态码</h2><p>1xx（临时响应）<br>表示临时响应并需要请求者继续执行操作的状态码。</p>
<table>
<thead>
<tr>
<th>100（继续）</th>
<th>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</th>
</tr>
</thead>
<tbody><tr>
<td>101（切换协议）</td>
<td>请求者已要求服务器切换协议，服务器已确认并准备切换。</td>
</tr>
</tbody></table>
<p>2xx （成功）</p>
<p>表示成功处理了请求的状态码。</p>
<table>
<thead>
<tr>
<th>200（成功）</th>
<th>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。</th>
</tr>
</thead>
<tbody><tr>
<td>201（已创建）</td>
<td>请求成功并且服务器创建了新的资源。</td>
</tr>
<tr>
<td>202（已接受）</td>
<td>服务器已接受请求，但尚未处理。</td>
</tr>
<tr>
<td>203（非授权信息）</td>
<td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td>
</tr>
<tr>
<td>204（无内容）</td>
<td>服务器成功处理了请求，但没有返回任何内容。</td>
</tr>
<tr>
<td>205（重置内容）</td>
<td>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。</td>
</tr>
<tr>
<td>206（部分内容）</td>
<td>服务器成功处理了部分 GET 请求。</td>
</tr>
</tbody></table>
<p>3xx （<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%AE%9A%E5%90%91&spm=1001.2101.3001.7020">重定向</a>）<br>要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的<a target="_blank" rel="noopener" href="http://www.google.cn/support/webmasters/bin/answer.py?answer=35156">网络抓取</a>页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</p>
<table>
<thead>
<tr>
<th>300（多种选择）</th>
<th>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</th>
</tr>
</thead>
<tbody><tr>
<td>301（永久移动）</td>
<td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</td>
</tr>
<tr>
<td>302（临时移动）</td>
<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td>
</tr>
<tr>
<td>303（查看其他位置）</td>
<td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。</td>
</tr>
<tr>
<td>304（未修改）</td>
<td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</td>
</tr>
<tr>
<td>305（使用代理）</td>
<td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td>
</tr>
<tr>
<td>307（临时重定向）</td>
<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href&#x3D;answer.py?answer&#x3D;&gt;301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td>
</tr>
</tbody></table>
<p>4xx（请求错误）<br>这些状态码表示请求可能出错，妨碍了服务器的处理。</p>
<table>
<thead>
<tr>
<th>400（错误求）</th>
<th>服务器不理解请求的语法。</th>
</tr>
</thead>
<tbody><tr>
<td>401（未授权）</td>
<td>请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</td>
</tr>
<tr>
<td>403（禁止）</td>
<td>服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</td>
</tr>
<tr>
<td>404（未找到）</td>
<td>服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具<a target="_blank" rel="noopener" href="http://www.google.cn/support/webmasters/bin/answer.py?answer=35237">“诊断”标签的 robots.txt 页</a>上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 <a target="_blank" rel="noopener" href="http://www.google.cn/support/webmasters/bin/answer.py?answer=35122">HTTP 错误页面</a>上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。</td>
</tr>
<tr>
<td>405（方法禁用）</td>
<td>禁用请求中指定的方法。</td>
</tr>
<tr>
<td>406（不接受）</td>
<td>无法使用请求的内容特性响应请求的网页。</td>
</tr>
<tr>
<td>407（需要代理授权）</td>
<td>此状态码与 &lt;a href&#x3D;answer.py?answer&#x3D;35128&gt;401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。</td>
</tr>
<tr>
<td>408（请求超时）</td>
<td>服务器等候请求时发生超时。</td>
</tr>
<tr>
<td>409（冲突）</td>
<td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。</td>
</tr>
<tr>
<td>410（已删除）</td>
<td>如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。</td>
</tr>
<tr>
<td>411（需要有效长度）</td>
<td>服务器不接受不含有效内容长度标头字段的请求。</td>
</tr>
<tr>
<td>412（未满足前提条件）</td>
<td>服务器未满足请求者在请求中设置的其中一个前提条件。</td>
</tr>
<tr>
<td>413（请求实体过大）</td>
<td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td>
</tr>
<tr>
<td>414（请求的 URI 过长）</td>
<td>请求的 URI（通常为网址）过长，服务器无法处理。</td>
</tr>
<tr>
<td>415（不支持的媒体类型）</td>
<td>请求的格式不受请求页面的支持。</td>
</tr>
<tr>
<td>416（请求范围不符合要求）</td>
<td>如果页面无法提供请求的范围，则服务器会返回此状态码。</td>
</tr>
<tr>
<td>417（未满足期望值）</td>
<td>服务器未满足”期望”请求标头字段的要求。</td>
</tr>
</tbody></table>
<p>5xx（服务器错误）<br>这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p>
<table>
<thead>
<tr>
<th>500（服务器内部错误）</th>
<th>服务器遇到错误，无法完成请求。</th>
</tr>
</thead>
<tbody><tr>
<td>501（尚未实施）</td>
<td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td>
</tr>
<tr>
<td>502（错误网关）</td>
<td>服务器作为网关或代理，从上游服务器收到无效响应。</td>
</tr>
<tr>
<td>503（服务不可用）</td>
<td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td>
</tr>
<tr>
<td>504（网关超时）</td>
<td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td>
</tr>
<tr>
<td>505（HTTP 版本不受支持）</td>
<td>服务器不支持请求中所用的 HTTP 协议版本。</td>
</tr>
</tbody></table>
<h2 id="6、get和post有什么区别"><a href="#6、get和post有什么区别" class="headerlink" title="6、get和post有什么区别"></a>6、get和post有什么区别</h2><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p>
<p>GET产生的URL地址可以被Bookmark，而POST不可以。</p>
<p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p>
<p>GET请求只能进行url编码，而POST支持多种编码方式。</p>
<p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p>
<p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p>
<p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p>
<p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
<p>GET参数通过URL传递，POST放在Request body中。</p>
<h2 id="7、异步请求"><a href="#7、异步请求" class="headerlink" title="7、异步请求"></a>7、异步请求</h2><h1 id="HTML、CSS"><a href="#HTML、CSS" class="headerlink" title="HTML、CSS"></a>HTML、CSS</h1><h2 id="1、HTML语义化"><a href="#1、HTML语义化" class="headerlink" title="1、HTML语义化"></a>1、HTML语义化</h2><p>HTML5的语义化指的是<code>合理正确的使用语义化的标签来创建页面结构</code>。</p>
<p>语义化优点：</p>
<ul>
<li>在<code>没CSS样式的情况下，页面整体也会呈现很好的结构效果</code></li>
<li><code>代码结构清晰</code>，易于阅读，</li>
<li><code>利于开发和维护</code> 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li><code>有利于搜索引擎优化（SEO）</code>，搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
</ul>
<h2 id="2、CSS选择器"><a href="#2、CSS选择器" class="headerlink" title="2、CSS选择器"></a>2、CSS选择器</h2><p>选择器类型：</p>
<p><strong>选择器：</strong></p>
<ul>
<li>id选择器(#myid)</li>
<li>类选择器(.myclass)</li>
<li>属性选择器(a[rel&#x3D;”external”])</li>
<li>伪类选择器(a:hover, li:nth-child)</li>
<li>标签选择器(div, h1,p)</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器(ul &gt; li)</li>
<li>后代选择器(li a)</li>
<li>通配符选择器(*)</li>
</ul>
<p><strong>优先级：</strong></p>
<ul>
<li><code>!important</code></li>
<li>内联样式（1000）</li>
<li>ID选择器（0100）</li>
<li>类选择器&#x2F;属性选择器&#x2F;伪类选择器（0010）</li>
<li>元素选择器&#x2F;伪元素选择器（0001）</li>
<li>关系选择器&#x2F;通配符选择器（0000）</li>
</ul>
<h2 id="3、position属性"><a href="#3、position属性" class="headerlink" title="3、position属性"></a>3、position属性</h2><p><strong>固定定位 fixed</strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</p>
<p><strong>相对定位 relative</strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p>
<p><strong>绝对定位 absolute</strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p>
<p><strong>粘性定位 sticky</strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</p>
<p><strong>默认定位 Static</strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。inherit: 规定应该从父元素继承 position 属性的值。</p>
<h2 id="4、box-sizing属性"><a href="#4、box-sizing属性" class="headerlink" title="4、box-sizing属性"></a>4、box-sizing属性</h2><p>box-sizing 属性定义如何计算一个元素的总宽度和总高度，主要设置是否需要加上内边距(padding)和边框等。</p>
<p>content-box：指定盒模型为 W3C 标准模型，设置 border、padding 会增加元素 width与 height 的尺寸。</p>
<p>border-box：指定盒模型为 IE模型（怪异模式），设置 border、padding 不会影响元素 width 与 height 的尺寸。</p>
<h2 id="5、CSS盒子模型"><a href="#5、CSS盒子模型" class="headerlink" title="5、CSS盒子模型"></a>5、CSS盒子模型</h2><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括标准盒模型和怪异盒模型</p>
<p>标准盒模型： 一个块的总宽度 &#x3D; width+	margin(左右)+padding(左右)+border(左右) </p>
<p>怪异盒模型：一个块的总宽度 &#x3D; width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p>
<h2 id="6、BFC"><a href="#6、BFC" class="headerlink" title="6、BFC"></a>6、BFC</h2><p>定义：块级格式化上下文，独立的渲染区域，这个区域的子元素不会影响到外面的元素</p>
<p>形成的条件：a.浮动 b. 非静态定位，c. overflow:hidden d. display:table </p>
<p>解决的问题：a. 浮动元素重叠（让父元素的高度包含子浮动元素） b. 父元素高度塌陷 b. margin重叠</p>
<h2 id="7、居中"><a href="#7、居中" class="headerlink" title="7、居中"></a>7、居中</h2><p><strong>水平居中</strong></p>
<ul>
<li><p>对于 行内元素 : <code>text-align: center</code>;</p>
</li>
<li><p>对于确定宽度的块级元素：</p>
<p>（1）width和margin实现。<code>margin: 0 auto</code>;</p>
<p>（2）绝对定位和margin-left: (父width - 子width）&#x2F;2, 前提是父元素position: relative</p>
</li>
<li><p>对于宽度未知的块级元素</p>
<p>（1）<code>table标签配合margin左右auto实现水平居中</code>。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</p>
<p>（2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</p>
<p>（3）<code>绝对定位+transform</code>，设置元素相对父级定位<code>position:absolute;left:50%;top:50%</code>，让自身平移自身高度50% ，然后<code>transform:translate(-50%,-50%)</code>，这种方式兼容性好，被广泛使用的一种方式</p>
<p>（4）flex布局使用<code>justify-content:center</code></p>
</li>
</ul>
<p><strong>垂直居中</strong></p>
<ol>
<li>利用 <code>line-height</code> 实现居中，这种方法适合纯文字类</li>
<li>通过设置父容器 相对定位 ，子级设置 <code>绝对定位</code>，然后top、left、right、bottom设为0，标签通过margin实现自适应居中</li>
<li>弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li>
<li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li>
<li><code>table 布局</code>，父级通过转换成表格形式，<code>然后子级设置 vertical-align 实现</code>。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。</li>
</ol>
<h2 id="8、隐藏页面中某元素"><a href="#8、隐藏页面中某元素" class="headerlink" title="8、隐藏页面中某元素"></a>8、隐藏页面中某元素</h2><p>1.<code>opacity：0</code>，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的</p>
<p>2.<code>visibility：hidden</code>，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p>
<p>3.<code>display：none</code>，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p>
<h2 id="9、页面布局"><a href="#9、页面布局" class="headerlink" title="9、页面布局"></a>9、页面布局</h2><ul>
<li>Flex</li>
</ul>
<p>容器的属性：</p>
<ul>
<li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;</li>
<li>flex-wrap：决定换行规则 flex-wrap: nowrap （不换）| wrap（超出就换） | wrap-reverse（和warp相反）;</li>
<li>flex-flow： .box { flex-flow: || ; }</li>
<li>justify-content：对其方式，水平主轴对齐方式</li>
<li>align-items：对齐方式，副轴线方向，适用于单行</li>
<li>align-content：同align-items，不过适用于多行</li>
</ul>
<p>项目的属性（元素的属性）：</p>
<ul>
<li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li>
<li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li>
<li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小</li>
<li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li>
<li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li>
<li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li>
<li>align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li>
</ul>
<ul>
<li>rem布局</li>
</ul>
<p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem &#x3D; 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p>
<p><strong>优点</strong>：可以快速适用移动端布局，字体，图片高度</p>
<p><strong>缺点</strong>：</p>
<p>①目前 ie 不支持，对 pc 页面来讲使用次数不多；<br> ②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；<br> ③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。</p>
<ul>
<li>百分比布局</li>
</ul>
<p>​		流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动web开发使用的比较常见的布局方式。</p>
<p>​		通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p>
<p><strong>缺点</strong>：</p>
<p>（1）计算困难<br> （2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</p>
<ul>
<li>浮动布局</li>
</ul>
<p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p>
<p><strong>优点</strong></p>
<p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题</p>
<p><strong>缺点</strong></p>
<p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，<code>会造成父级元素高度塌陷</code>。</p>
<p>清除浮动方法：</p>
<p>1、添加额外标签清除浮动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;f&quot;&gt;&lt;/div&gt;</span><br><span class="line">    //添加额外标签并且添加clear属性</span><br><span class="line">    &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>2、父元素设置<code>overflow:hidden</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot; style=&quot;overflow:hidden&quot;&gt;</span><br><span class="line">    //将父元素的overflow设置为hidden</span><br><span class="line">    &lt;div class=&quot;f&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>3、父元素设置<code>overflow:auto</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot; style=&quot;overflow:auto&quot;&gt;</span><br><span class="line">    //将父元素的overflow设置为hidden</span><br><span class="line">    &lt;div class=&quot;f&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>4、父元素也设置为浮动元素</p>
<p>5、使用伪元素<code>:after</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在css中添加:after伪元素</span><br><span class="line">.parent:after&#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    visibility:hidden;</span><br><span class="line">    display:block;</span><br><span class="line">    width:100%;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;f&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="10、重排和重绘"><a href="#10、重排和重绘" class="headerlink" title="10、重排和重绘"></a>10、重排和重绘</h2><p><code>重排/回流（Reflow）</code>：当<code>DOM</code>的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</p>
<p><code>重绘(Repaint)</code>: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</p>
<ul>
<li>如何触发重排和重绘？</li>
</ul>
<p>添加、删除、更新DOM节点</p>
<p>通过display: none隐藏一个DOM节点-触发重排和重绘</p>
<p>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</p>
<p>移动或者给页面中的DOM节点添加动画</p>
<p>添加一个样式表，调整样式属性</p>
<p>用户行为，例如调整窗口大小，改变字号，或者滚动。</p>
<ul>
<li>如何避免重绘和重排</li>
</ul>
<p>JavaScript优化法<br>（1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。<br>（2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中，也就是虚拟DOM<br>（3）避免频繁读取会引发回流&#x2F;重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br>CSS优化法<br>（1）使用 transform 替代 top<br>（2）使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局 （3）避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。<br>（4）尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。<br>（5）避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。<br>（6）将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。<br>（7）避免使用CSS表达式，可能会引发回流。<br>（8）将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。<br>（9）CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1、SPA和MVC和MVVM"><a href="#1、SPA和MVC和MVVM" class="headerlink" title="1、SPA和MVC和MVVM"></a>1、SPA和MVC和MVVM</h2><p>1、SPA：整个项目只有一个html文件，路由切换进行页面切换</p>
<p>优点：</p>
<p>​	一、用户体验及交互比较流畅</p>
<p>​	二、提取组件开发，易于后期维护</p>
<p>​	三、减轻服务器压力</p>
<p>缺点：</p>
<p>​	一、不利于SEO优化（搜索引擎优化），搜索引擎爬虫只会爬html，不会爬js</p>
<p>​	二、第一次进入比较慢（已有按需加载策略）</p>
<p>2、MVC和MVVM架构</p>
<p>​	一、MVC：View接受用户行为通知controller，controller通知model进行数据更新</p>
<p>​	Model通过View进行页面更新</p>
<p>​	Model和View进行交互</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111708141.png" alt="image-20230311170844026"></p>
<p>​	二、MVVM：数据双向绑定</p>
<p>​		<code>视图模型双向绑定</code>，是<code>Model-View-ViewModel</code>的缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel。Model</code>层代表数据模型，<code>View</code>代表UI组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。以前是操作DOM结构更新视图，现在是<code>数据驱动视图</code>。</p>
<p><strong>Observer（数据监听器）</strong> : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p>
<p><strong>Watcher（订阅者）</strong> : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>
<li>自身必须有一个update()方法</li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li>
</ol>
<p><strong>Compile（指令解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303231547636.png" alt="img"></p>
<p>​		用户行为更改数据，数据可以主动触发视图更新</p>
<p>​		双向绑定通过ViewModel进行交互</p>
<p>​		Model和View不直接进行交互</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111712276.png" alt="image-20230311171248215"></p>
<h2 id="2、vue2-x2F-3生命周期"><a href="#2、vue2-x2F-3生命周期" class="headerlink" title="2、vue2&#x2F;3生命周期"></a>2、vue2&#x2F;3生命周期</h2><p><strong>Vue2</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &#123;msg&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;button id=&quot;btn&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> const app = new Vue(&#123;</span><br><span class="line">     el:&quot;#app&quot;,</span><br><span class="line">     data: &#123;</span><br><span class="line">         msg:&quot;你好！&quot;,</span><br><span class="line">         msg2:&quot;不好！&quot;</span><br><span class="line">     &#125;,</span><br><span class="line">     beforeCreate() &#123;</span><br><span class="line">         console.log(&quot;beforeCreate,挂载了vue实例的方法，但data还没挂载&quot;, this.msg)</span><br><span class="line">     &#125;,</span><br><span class="line">     created() &#123;</span><br><span class="line">         console.log(&quot;created, 挂载了data&quot;, this.msg)</span><br><span class="line">     &#125;,</span><br><span class="line">     beforeMount() &#123;</span><br><span class="line">         console.log(&quot;data没有渲染到页面&quot;, document.getElementById(&quot;app&quot;).innerHTML)</span><br><span class="line">     &#125;,</span><br><span class="line">     mounted() &#123;</span><br><span class="line">         console.log(&quot;mounted data渲染到了页面&quot;, document.getElementById(&quot;app&quot;).innerHTML)</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             this.msg = &quot;hello!&quot;</span><br><span class="line">         &#125;, 2000);</span><br><span class="line">     &#125;,</span><br><span class="line">     beforeUpdate() &#123;</span><br><span class="line">         console.log(&quot;beforeUpdate数据更改直到DOM更改之前&quot;, document.getElementById(&quot;app&quot;).innerHTML)//只有数据更变(data中)和dom更改(div中)两个条件都达成了，才会触发update</span><br><span class="line">     &#125;,</span><br><span class="line">     updated() &#123;</span><br><span class="line">         console.log(&quot;update数据更改导致DOM更改之后&quot;, document.getElementById(&quot;app&quot;).innerHTML)//只有数据更变和dom更改两个条件都达成了，才会触发update</span><br><span class="line">     &#125;,</span><br><span class="line">     beforeDestroy() &#123;</span><br><span class="line">         console.log(&quot;beforeDestroy!&quot;)</span><br><span class="line">     &#125;,</span><br><span class="line">     destroyed() &#123;</span><br><span class="line">         console.log(&quot;destroyed!&quot;)</span><br><span class="line">     &#125;,</span><br><span class="line"> &#125;)</span><br><span class="line"> document.getElementById(&quot;btn&quot;).onclick = () =&gt; &#123;</span><br><span class="line">     app.$destroy()</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>建议运行感受一哈！</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111826919.png" alt="image-20230311182622845"></p>
<p><strong>Vue3</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &#123;msg&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> const &#123;createApp, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, ref&#125; = Vue</span><br><span class="line"> const app = createApp(&#123;</span><br><span class="line">     //vue3 删除了beforeCreate created 用 setup代替</span><br><span class="line">     //destroy 改为了 unmount</span><br><span class="line">     setup:(props) =&gt; &#123;</span><br><span class="line">         msg = ref(&quot;Hi~~~&quot;)</span><br><span class="line">         console.log(&#x27;data没有渲染页面噢！&#x27;)</span><br><span class="line">         onBeforeMount(()=&gt;&#123;</span><br><span class="line">             console.log(&quot;onBeforeMount data没有渲染到页面&quot;, document.getElementById(&quot;app&quot;).innerHTML)</span><br><span class="line">         &#125;),</span><br><span class="line">         onMounted(()=&gt;&#123;</span><br><span class="line">             console.log(&quot;onMounted data渲染到了页面&quot;, document.getElementById(&quot;app&quot;).innerHTML)</span><br><span class="line">             setTimeout(() =&gt; &#123;</span><br><span class="line">                 msg.value = &quot;hello!&quot;</span><br><span class="line">             &#125;, 2000);</span><br><span class="line">         &#125;),</span><br><span class="line">         onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">             console.log(&quot;更新前&quot;)</span><br><span class="line">         &#125;),</span><br><span class="line">         onUpdated(() =&gt; &#123;</span><br><span class="line">             console.log(&quot;更新后&quot;)</span><br><span class="line">         &#125;),</span><br><span class="line">         onBeforeUnmount(() =&gt; &#123;</span><br><span class="line">             console.log(&quot;销毁前&quot;)</span><br><span class="line">         &#125;),</span><br><span class="line">         onUnmounted(() =&gt; &#123;</span><br><span class="line">             console.log(&quot;销毁后&quot;)</span><br><span class="line">         &#125;)</span><br><span class="line">         return &#123;msg&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).mount(&quot;#app&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111827410.png" alt="image-20230311182721353"></p>
<h2 id="3、watch和computed"><a href="#3、watch和computed" class="headerlink" title="3、watch和computed"></a>3、watch和computed</h2><p><strong>computed</strong>：计算属性，计算出一个结果，函数值改变会导致重新计算</p>
<p>1、初始化的时候会自动计算一次</p>
<p>2、computed会读取缓存数据，后面不改变值的话，就会取用缓存数据</p>
<p><strong>watch</strong>：监控某个数据，被监控的数据更改，则watch执行</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123;ref , computed, watch,onMounted&#125; from &quot;vue&quot;</span><br><span class="line">const num1 = ref(1)</span><br><span class="line">// computed: 计算属性，计算出一个结果，函数值改变会导致重新计算</span><br><span class="line">// 初始化的时候会自动计算一次</span><br><span class="line">// computed会读取缓存数据</span><br><span class="line">const num2 = computed(() =&gt; &#123;</span><br><span class="line">console.log(&#x27;computed执行&#x27;)</span><br><span class="line">return num1.value  + 10</span><br><span class="line">&#125;)</span><br><span class="line">//watch：监控某个数据，被监控的数据更改，则watch执行</span><br><span class="line">const num3 = ref(&#x27;未成年&#x27;)</span><br><span class="line">watch(num1,(newValue, oldValue)=&gt;&#123;</span><br><span class="line">console.log(&#x27;watch执行&#x27;)</span><br><span class="line">if(newValue &gt; 18)&#123;</span><br><span class="line"> num3.value = &#x27;已成年&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line"> num1.value += 20</span><br><span class="line">&#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;p&gt;小红年龄&#123;num1&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;小红哥哥年龄&#123;num2&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p&gt;小红&#123;num3&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4、router、routes和route"><a href="#4、router、routes和route" class="headerlink" title="4、router、routes和route"></a>4、router、routes和route</h2><p>router：路由对象； routes：路由配置； route：当前路由信息</p>
<p>1、router：路由器（new的路由器对象），包含一些操作路由的功能函数，来实现编程式导航。一般指的是在任何组件内访问路由。如：路由编程式导航的$router.push()<br>2、routes：指创建vue-router路由实例的配置项。用来配置多个route路由对象<br>3、route：指路由对象表示当前激活的路由的状态信息。一般用来获取页面信息.如：this.$route指的是当前路由对象，path&#x2F;meta&#x2F;query&#x2F;params</p>
<h2 id="5、v-if和v-show"><a href="#5、v-if和v-show" class="headerlink" title="5、v-if和v-show"></a>5、v-if和v-show</h2><p>v-if：控制元素是否渲染（动态的向DOM树中添加或删除DOM元素）</p>
<p>v-show：控制的是样式的 display：none</p>
<p>共同点：</p>
<p> 在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 。</p>
<ul>
<li>当表达式都为 false 时，都不会占据页面位置</li>
<li>当表达式结果为 true 时，都会占据页面的位置</li>
</ul>
<p>不同点：</p>
<p>v-show 是通过控制display属性来进行dom的显示与隐藏</p>
<p>v-if 是真正意义上的条件渲染，为true是渲染（dom存在），为false时不存在（dom不存在）</p>
<p>v-if 与 v-show 都能控制dom元素在页面的显示</p>
<p>v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）</p>
<p>如果需要非常频繁地切换，则使用 v-show 较好</p>
<p>如果在运行时条件很少改变，则使用 v-if 较好</p>
<h2 id="6、vue组件传参"><a href="#6、vue组件传参" class="headerlink" title="6、vue组件传参"></a>6、vue组件传参</h2><ul>
<li>父传子：props</li>
</ul>
<p>&lt;父组件通过标签属性进行数据传递&gt;</p>
<p>子组件通过defineProps获取父组件传过来的数据</p>
<p>子组件不允许更改父组件的数据</p>
<ul>
<li>子传父：emit</li>
</ul>
<p>emits触发组件的自定义事件</p>
<ul>
<li>兄弟组件传参：事件总线bus Vue3使用mitt插件</li>
</ul>
<p>事件总线：相当于全局的时间管理</p>
<p>使用：</p>
<p>​	mitt.emit(‘方法名’,参数)：触发某个方法</p>
<p>​	mitt.on(‘对应方法名’, callback)：监听某个方法</p>
<p>​	mitt.off(‘移除对应方法’)：移除某个方法，一般放再onUnmounted声明周期里面</p>
<h2 id="7、Vue项目中key的作用"><a href="#7、Vue项目中key的作用" class="headerlink" title="7、Vue项目中key的作用"></a>7、Vue项目中key的作用</h2><ul>
<li><p>key的作用是为了在diff算法执行时更快的找到对应的节点，<code>提高diff速度，更高效的更新虚拟DOM</code>;</p>
<p>Vue	是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p>
</li>
<li><p>为了在数据变化时强制更新组件，以避免<code>“就地复用”</code>带来的副作用。</p>
<p>当 Vue.js 用 <code>v-for</code> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</p>
</li>
</ul>
<h2 id="8、Vuex"><a href="#8、Vuex" class="headerlink" title="8、Vuex"></a>8、Vuex</h2><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p>
<ol>
<li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，</li>
</ol>
<p>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</p>
<ol>
<li>State：定义了应用的状态数据</li>
<li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），</li>
</ol>
<p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p>
<h2 id="9、Diff算法"><a href="#9、Diff算法" class="headerlink" title="9、Diff算法"></a>9、Diff算法</h2><p>​		每一个真实的dom都有对应的一个虚拟dom，即一个JS对象。当一个dom发生变化时候，其虚拟dom也会发生变化，这时就需要判断前后两个虚拟dom的变化，找出两者差异，这时候就需要diff算法找出差异，然后最小化更新视图。本质就是比较两个JS对象的差异。</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251347564.png" alt="image-20230325134724365"></p>
<p>updateChildren</p>
<p> 1、同级比对 2、首尾比对</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251347247.png" alt="image-20230325134745100"></p>
<p>真实DOM的位置以比较后newVnode的位置为基准。当新旧节点中其中一个有end和start相交，结束。</p>
<p>Diff算法主要就是在虚拟DOM树发生变化后，生成DOM树更新补丁的方式，对比新旧两株虚拟DOM树的变更差异，将更新补丁作用于真实DOM，以最小成本完成视图更新；2、框架会将所有的结点先转化为虚拟节点Vnode，在发生更改后将VNode和原本页面的OldNode进行对比，然后以VNode为基准，在oldNode上进行准确的修改。（修改准则：原本没有新版有，则增加；原本有新版没有，则删除；都有则进行比较，都为文本结点则替换值；都为静态资源不处理；都为正常结点则替换）</p>
<h2 id="10、常用指令"><a href="#10、常用指令" class="headerlink" title="10、常用指令"></a>10、常用指令</h2><p>{} 两个大括号 双向绑定值语法</p>
<p>v-text 编译成文字段落</p>
<p>v-html 把html代码段编译成元素</p>
<p>v-bind 简写 : 绑定值成变量</p>
<p>v-for 循环</p>
<p>v-if、v-else-if、v-else 条件渲染（不占位）</p>
<p>v-show 条件渲染（占位）</p>
<p>v-on 简写 @ 一般用来绑定事件</p>
<p>v-pre 跳过编译（几乎99%不会用）</p>
<p>v-once 仅渲染一次（几乎99%不会用）</p>
<p>v-cloak 插值闪烁问题</p>
<p>v-model 双向绑定值，利用Object.defineProperty</p>
<h2 id="11、ref和reactive区别"><a href="#11、ref和reactive区别" class="headerlink" title="11、ref和reactive区别"></a>11、ref和reactive区别</h2><ul>
<li>从定义数据方面：<br>ref通常用来定义基本类型数据<br>reactive用来定义：对象（或者数组）类型数据<br>ref也可以用来定义对象或者数组类型的数据，内部会通过reactive转为代理对象</li>
<li>从原理方面：<br>ref通过Object.defineProperty()的get和set实现数据代理。<br>reactive使用Proxy实现数据代理，并且通过Reflect操作源对象内部的数据。</li>
<li>从使用方面：<br>ref操作数据需要.value，template模板中不需要。<br>reactive都不需要.value</li>
</ul>
<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="1、优化-Webpack-的构建速度"><a href="#1、优化-Webpack-的构建速度" class="headerlink" title="1、优化 Webpack 的构建速度"></a>1、优化 Webpack 的构建速度</h2><ul>
<li>使用高版本的 Webpack （使用webpack4）</li>
<li>多线程&#x2F;多实例构建：HappyPack(不维护了)、thread-loader</li>
<li>缩小打包作用域：<ul>
<li>exclude&#x2F;include (确定 loader 规则范围)</li>
<li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li>
<li>resolve.extensions 尽可能减少后缀尝试的可能性</li>
<li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li>
<li>IgnorePlugin (完全排除模块)</li>
<li>合理使用alias</li>
</ul>
</li>
<li>充分利用缓存提升二次构建速度：<ul>
<li>babel-loader 开启缓存</li>
<li>terser-webpack-plugin 开启缓存</li>
<li>使用 cache-loader 或者 hard-source-webpack-plugin<br> 注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader</li>
</ul>
</li>
</ul>
<ul>
<li>DLL：使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li>
</ul>
<h2 id="2、优化-Webpack-的打包体积"><a href="#2、优化-Webpack-的打包体积" class="headerlink" title="2、优化 Webpack 的打包体积"></a>2、优化 Webpack 的打包体积</h2><ul>
<li>压缩代码</li>
<li>提取页面公共资源：</li>
<li>Tree shaking</li>
<li>Scope hoisting</li>
<li>图片压缩</li>
<li>动态Polyfill</li>
</ul>
<h2 id="3、webpack构建流程"><a href="#3、webpack构建流程" class="headerlink" title="3、webpack构建流程"></a>3、webpack构建流程</h2><p>​		Webpack启动后，从entry开始，去递归解析entry依赖的所有module，再找到每一个module的时候，会根据module.rules里配置的不同loader进行相应的转换，对module进行转换后再解析出当前module依赖的其他的一些模块，这些module在entry里面，它会进行分组，解析成一个个的chunk，最后webpack会将所有chunk转换成文件输出的output，在整个构建流程中，通过plugin注入钩子，最后输出多个模块组合成的文件。</p>
<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><h2 id="1、Babel编译过程"><a href="#1、Babel编译过程" class="headerlink" title="1、Babel编译过程"></a>1、Babel编译过程</h2><p>Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<p><code>Babel</code> 本质上就是在操作 <code>AST</code> 来完成代码的转译。AST是抽象语法树（Abstract Syntax Tree, AST）</p>
<p><code>Babel</code> 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：</p>
<ol>
<li><strong>解析（Parse）</strong> ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。</li>
<li><strong>转换（Transform）</strong> ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li>
<li><strong>生成（Generate）</strong> ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。</li>
</ol>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1、基本指令"><a href="#1、基本指令" class="headerlink" title="1、基本指令"></a>1、基本指令</h2><p>git clone 仓库地址<br>git init<br>git remote add origin 添加仓库地址<br>git remote remove origin 删除仓库地址<br>增删改：git add . &#x2F; commit &#x2F; push</p>
<p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251430018.jpeg" alt="img"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/BiAJiii">Projects</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7"><span class="toc-number">1.</span> <span class="toc-text">面试刷刷刷</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E3%80%81TS%E3%80%81ES6"><span class="toc-number">2.</span> <span class="toc-text">JS、TS、ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">1、传值和传址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2、判断数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81slice%E3%80%81split%E3%80%81splice"><span class="toc-number">2.3.</span> <span class="toc-text">3、slice、split、splice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4、数组遍历方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.5.</span> <span class="toc-text">5、深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81this"><span class="toc-number">2.6.</span> <span class="toc-text">6、this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%94%B9%E5%8F%98this%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">7、改变this的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81new%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">8、new的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.9.</span> <span class="toc-text">9、异步解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BEprototpye-x2F-proto"><span class="toc-number">2.10.</span> <span class="toc-text">10、原型链prototpye&#x2F;_proto_</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-number">2.11.</span> <span class="toc-text">11、闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">2.12.</span> <span class="toc-text">12、防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81nextTick"><span class="toc-number">2.13.</span> <span class="toc-text">13、nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.14.</span> <span class="toc-text">14、JS运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.15.</span> <span class="toc-text">15、块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.16.</span> <span class="toc-text">16、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81var%E3%80%81let%E3%80%81const"><span class="toc-number">2.17.</span> <span class="toc-text">17、var、let、const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.18.</span> <span class="toc-text">18、JS垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81EventLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.19.</span> <span class="toc-text">19、EventLoop 事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81setTimeout%E3%80%81Promise%E3%80%81Async-x2F-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">20、setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.21.</span> <span class="toc-text">21、图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">2.22.</span> <span class="toc-text">22、DOM事件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.23.</span> <span class="toc-text">23、事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81-Object%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">2.24.</span> <span class="toc-text">24、 Object构造函数上语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81Dom%E6%93%8D%E4%BD%9C"><span class="toc-number">2.25.</span> <span class="toc-text">25、Dom操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">3.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1、三次握手、四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81TCP%E5%92%8CUDP"><span class="toc-number">3.2.</span> <span class="toc-text">2、TCP和UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81HTTP%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.</span> <span class="toc-text">3、HTTP跨域请求解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4、输入URL到加载页面的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.5.</span> <span class="toc-text">5、常见状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81get%E5%92%8Cpost%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">6、get和post有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">3.7.</span> <span class="toc-text">7、异步请求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML%E3%80%81CSS"><span class="toc-number">4.</span> <span class="toc-text">HTML、CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">1、HTML语义化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CSS%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2、CSS选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81position%E5%B1%9E%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">3、position属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81box-sizing%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">4、box-sizing属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">5、CSS盒子模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81BFC"><span class="toc-number">4.6.</span> <span class="toc-text">6、BFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%B1%85%E4%B8%AD"><span class="toc-number">4.7.</span> <span class="toc-text">7、居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%9F%90%E5%85%83%E7%B4%A0"><span class="toc-number">4.8.</span> <span class="toc-text">8、隐藏页面中某元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="toc-number">4.9.</span> <span class="toc-text">9、页面布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">4.10.</span> <span class="toc-text">10、重排和重绘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">5.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81SPA%E5%92%8CMVC%E5%92%8CMVVM"><span class="toc-number">5.1.</span> <span class="toc-text">1、SPA和MVC和MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81vue2-x2F-3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2、vue2&#x2F;3生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81watch%E5%92%8Ccomputed"><span class="toc-number">5.3.</span> <span class="toc-text">3、watch和computed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81router%E3%80%81routes%E5%92%8Croute"><span class="toc-number">5.4.</span> <span class="toc-text">4、router、routes和route</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81v-if%E5%92%8Cv-show"><span class="toc-number">5.5.</span> <span class="toc-text">5、v-if和v-show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82"><span class="toc-number">5.6.</span> <span class="toc-text">6、vue组件传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Vue%E9%A1%B9%E7%9B%AE%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.7.</span> <span class="toc-text">7、Vue项目中key的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Vuex"><span class="toc-number">5.8.</span> <span class="toc-text">8、Vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Diff%E7%AE%97%E6%B3%95"><span class="toc-number">5.9.</span> <span class="toc-text">9、Diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.10.</span> <span class="toc-text">10、常用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81ref%E5%92%8Creactive%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">11、ref和reactive区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack"><span class="toc-number">6.</span> <span class="toc-text">Webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="toc-number">6.1.</span> <span class="toc-text">1、优化 Webpack 的构建速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BC%98%E5%8C%96-Webpack-%E7%9A%84%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF"><span class="toc-number">6.2.</span> <span class="toc-text">2、优化 Webpack 的打包体积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">3、webpack构建流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Babel"><span class="toc-number">7.</span> <span class="toc-text">Babel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Babel%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">1、Babel编译过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git"><span class="toc-number">8.</span> <span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">8.1.</span> <span class="toc-text">1、基本指令</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&text="><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&is_video=false&description="><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&title="><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&name=&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E5%88%B7%E5%88%B7%E5%88%B7/&t="><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    Samuel
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/BiAJiii">Projects</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
