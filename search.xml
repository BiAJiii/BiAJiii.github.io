<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些数据结构与算法</title>
      <link href="/2023/01/10/%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/10/%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061452280.png" alt="image-20230106145213189"></p><ul><li>存储方式：</li></ul><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061501599.png" alt="image-20230106150159499"></p><h3 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061504675.png" alt="image-20230106150422377"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061518174.png" alt="image-20230106151827638"></p><ul><li>封装实现:</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//二叉树封装</span><br><span class="line">function BST() &#123;</span><br><span class="line">    //节点保存</span><br><span class="line">    function Node(key) &#123;</span><br><span class="line">        this.key = key </span><br><span class="line">        this.left = null</span><br><span class="line">        this.right = null</span><br><span class="line">    &#125;</span><br><span class="line">    //根属性</span><br><span class="line">    this.root = null;</span><br><span class="line">    </span><br><span class="line">    BST.prototype.insert = function (key) &#123;</span><br><span class="line">        let newNode = new Node(key)</span><br><span class="line">        //判断根是否存在</span><br><span class="line">        if(this.root === null)&#123;</span><br><span class="line">            this.root = newNode</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.NodeCompare(this.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BST.prototype.NodeCompare = function (oldNode, newNode) &#123;</span><br><span class="line">        //左查找</span><br><span class="line">        if(newNode.key &lt; oldNode.key) &#123;</span><br><span class="line">            if(oldNode.left !== null) &#123;</span><br><span class="line">                this.NodeCompare(oldNode.left, newNode)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                oldNode.left = newNode</span><br><span class="line">            &#125;</span><br><span class="line">        //右查找    </span><br><span class="line">        &#125; else if( newNode.key &gt; oldNode.key ) &#123;</span><br><span class="line">            if(oldNode.right !== null) &#123;</span><br><span class="line">                this.NodeCompare(oldNode.right, newNode)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                oldNode.right = newNode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alert(&#x27;当前数值已存在&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">const bst = new BST()</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li>遍历方法：</li></ul><p>1、先序遍历</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061608249.png" alt="image-20230106160858807"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//先序遍历</span><br><span class="line">//handler用于处理遍历显示形式</span><br><span class="line">BST.prototype.preTravelsal = function(handler) &#123;</span><br><span class="line">    this.preTravelsalNode(this.root, handler)</span><br><span class="line">&#125;</span><br><span class="line">//节点遍历</span><br><span class="line">//递归调用栈（前进后出）</span><br><span class="line">BST.prototype.preTravelsalNode = function(Node, handler)&#123;</span><br><span class="line">    if(Node !== null)&#123;</span><br><span class="line">        handler(Node.key)//这个其实可以看做是当前处理的节点</span><br><span class="line">        //处理左子节点</span><br><span class="line">        this.preTravelsalNode(Node.left, handler)</span><br><span class="line">        //如果左子节点没有，处理右子节点</span><br><span class="line">        this.preTravelsalNode(Node.right, handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>测试代码：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const bst = new BST()</span><br><span class="line"></span><br><span class="line">bst.insert(3)</span><br><span class="line">bst.insert(1)</span><br><span class="line">bst.insert(4)</span><br><span class="line">bst.insert(0)</span><br><span class="line">bst.insert(2)</span><br><span class="line"></span><br><span class="line">var result = &#x27;&#x27;</span><br><span class="line">bst.preTravelsal(function (key) &#123;</span><br><span class="line">    result += key + &#x27;-&#x27;</span><br><span class="line">&#125;) </span><br><span class="line">console.log(result)</span><br><span class="line">//结果：3-1-0-2-4</span><br></pre></td></tr></table></figure></blockquote><p>2、中序遍历</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061717225.png" alt="image-20230106171729924"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//先序遍历对调一下就好</span><br><span class="line">//处理左子节点</span><br><span class="line">this.preTravelsalNode(Node.left, handler)</span><br><span class="line">//处理该节点</span><br><span class="line">handler(Node.key)</span><br><span class="line">//处理右子节点</span><br><span class="line">this.preTravelsalNode(Node.right, handler)</span><br></pre></td></tr></table></figure></blockquote><p>3、后序遍历</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061720015.png" alt="image-20230106171937295"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同理</span><br><span class="line">//先序遍历对调一下就好</span><br><span class="line">//处理左子节点</span><br><span class="line">this.preTravelsalNode(Node.left, handler)</span><br><span class="line">//处理右子节点</span><br><span class="line">this.preTravelsalNode(Node.right, handler)</span><br><span class="line">//处理该节点</span><br><span class="line">handler(Node.key)</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li>删除节点</li></ul><p>1、查找删除的节点，找到进行下一步，未找到就return</p><p>注意：最好添加几个变量，方便后续删除</p><p>parent（删除节点的父节点） current（要删除的节点） isLeft（删除节点的左侧是否存在）</p><p>2、找到节点分为以下几个情况</p><p>​a、删除叶子点</p><p>​一：isLeft：ture ，让parent.left &#x3D; null</p><p>​二：isLeft：false ，让parent.right &#x3D; null</p><p>​b、删除有一个节点的子节点</p><p>​四种情况</p><p>​parent.left &#x3D; current.left</p><p>​parent.left &#x3D; current.right</p><p>​parent.right &#x3D; current.left</p><p>​parent.right &#x3D; current.right</p><p>​c、删除的节点有两个节点</p><p>​思路：该节点有左右两分支，其实有两种方案，如果选左边，则找到该节点左分支下最大的数字替代该节点。若选的为右边，则选择该节点右分支下最小的数字替代该节点。</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.prototype.BubbleSort = function () &#123;</span><br><span class="line">    let temp = null</span><br><span class="line">    let arr = this.array</span><br><span class="line">    for(let i = 0 ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        for(let j = 0; j &lt; arr.length - i; j++)&#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                temp = arr[j]</span><br><span class="line">                arr[j] = arr[j+1]</span><br><span class="line">                arr[j+1] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;冒泡后：&#x27; + arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091410723.png" alt="image-20230109141033549"></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​选择排序的实现思路是从未排序序列中找到最小的元素，放到已排序序列的首位，重复上述步骤，直到所有元素排序完毕。</p><p>1）假设未排序序列的第一个是最小值，记下该元素的位置，从前往后比较<br>2）若某个元素比该元素小，覆盖最小值的位置<br>3）重复第二个步骤，直到找到未排序的末尾<br>4）将未排序元素的第一个元素和最大元素交换位置<br>5）重复前面几个步骤，直到所有元素都已经排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //选择排序</span><br><span class="line">ArrayList.prototype.SelectSort = function () &#123;</span><br><span class="line">    let temp = null</span><br><span class="line">    let arr = this.array</span><br><span class="line">    let len = this.array.length</span><br><span class="line">    for( let i = 0 ; i &lt; len ; i++)&#123;</span><br><span class="line">        let index = i</span><br><span class="line">        for( let j = i+1; j &lt; len; j++)&#123;</span><br><span class="line">            if(arr[index] &gt; arr[j])&#123;</span><br><span class="line">                index = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[index]</span><br><span class="line">        arr[index] = temp</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;选择排序后：&#x27; + arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091440704.png" alt="image-20230109144042607"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091612833.png" alt="image-20230109161222605"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.prototype.InsertSort = function () &#123;</span><br><span class="line">    let Arr = this.array</span><br><span class="line">    let len = this.array.length</span><br><span class="line">    //因为每一次比较，标记index前的数组都被看做为一个整体，所以需要进行lenght-1次比较</span><br><span class="line">    for( let i = 1; i &lt; len ; i++)&#123;</span><br><span class="line">        //j对应需要比较数字的索引</span><br><span class="line">        //让j=i是为了不影响大循环中i</span><br><span class="line">        let j = i</span><br><span class="line">        //将需要比较数字记录为临时变量temp</span><br><span class="line">        let temp = Arr[i]</span><br><span class="line">        //由于插入比较是标记数字对前面的有序数组，进行从大到小的比较</span><br><span class="line">        //所以，当temp小于有序数组中对应数字，循环仍要进行</span><br><span class="line">        while(Arr[j-1] &gt; temp)&#123;</span><br><span class="line">            //由于temp小于该轮有序数组的数字，则要将该轮数字往后移，即index+1，且j--，进行下一轮比较</span><br><span class="line">            Arr[j] = Arr[j-1]</span><br><span class="line">            j--</span><br><span class="line">            //当temp与有序数组中所有数字进行比较仍未满足跳出while循环条件，即temp为有序数组中最小的数，直接在j==0的位置插入</span><br><span class="line">            if(j == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将temp插入到找到索引对应的位置中</span><br><span class="line">        Arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;插入排序：&#x27; + Arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091614746.png" alt="image-20230109161455585"></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>​希尔排序是通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。增量为：<strong>gap&#x3D;length&#x2F;2</strong></p><p>原理图示（假设数组长度为8）：</p><p>（1）gap为4</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091703499.png" alt="img"></p><p>（2）gap为2</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091704200.png" alt="img"></p><p>（3）gap为1</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091704566.png" alt="img"></p><p>其实希尔排序是基于插入排序的，只不过是希尔排序按间隔进行了分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//希尔排序</span><br><span class="line">    ArrayList.prototype.ShellSort = function() &#123;</span><br><span class="line">        let len = this.array.length</span><br><span class="line">        let arr = this.array</span><br><span class="line">        let gap = Math.floor(len/2)</span><br><span class="line">        while(gap &gt;= 1) &#123;</span><br><span class="line">            //类似插入算法那一套，但现在间隔变成了gap而不是1</span><br><span class="line">            for( let i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                let j = i</span><br><span class="line">                let temp = arr[j]</span><br><span class="line">                while(arr[j - gap] &gt; temp &amp;&amp; j &gt;= gap) &#123;</span><br><span class="line">                    arr[j] = arr[j-gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">            gap = Math.floor(gap / 2)</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#x27;希尔排序：&#x27; + arr)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091710987.png" alt="image-20230109171009853"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091714254.png" alt="image-20230109171448025"></p><p>基本思想：</p><p>1、选定pivot中心轴</p><p>2、将大于pivot的数字放在piovt右边</p><p>3、将小于pivot的数字放在piovt右边</p><p>4、分别对左右子序列重复前前三步操作（递归）</p><p>5、当递归尽头的左右子序列长度都为1时，跳出递归</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//快速排序</span><br><span class="line">ArrayList.prototype.QuickSort = function (L ,R) &#123;</span><br><span class="line">    // L和R是为了确定一开始左和右的数如：（0，8），而left和right会随着循环变化，</span><br><span class="line">    // 如果不设定L和R，会导致栈溢出</span><br><span class="line">    // 在递归过程中，right和left是不断变化的，而L和R会保持一开始输入的数字</span><br><span class="line">    let arr = this.array</span><br><span class="line">    let left = L</span><br><span class="line">    let right = R</span><br><span class="line">    //将数组最右边的设为piovt</span><br><span class="line">    //先左指针循环，再右指针循环</span><br><span class="line">    //如果pivot为最左边</span><br><span class="line">    //则右指针先循环，左指针再循环</span><br><span class="line">    let pivot = arr[right]</span><br><span class="line">    if(left &gt;= right) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        //左指针向右遍历，遇到比pivot大的数停止</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[left] &gt; pivot)&#123;</span><br><span class="line">            arr[right] = arr[left]</span><br><span class="line">        &#125;</span><br><span class="line">        //左指针向左遍历，遇到比pivot小的数停止</span><br><span class="line">        while(left &lt; right &amp;&amp; pivot &lt;= arr[right])&#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[right] &lt; pivot)&#123;</span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &gt;= right)&#123;</span><br><span class="line">            arr[left] = pivot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //pivot左边递归</span><br><span class="line">    this.QuickSort(L , left-1)</span><br><span class="line">    //pivot右边递归</span><br><span class="line">    this.QuickSort(left+1 ,R)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301101529051.png" alt="image-20230110152931858"></p><ul><li>X表示该数字放进了最右边的位置</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora图片共享（Github+Picgo+Typora）</title>
      <link href="/2023/01/05/Typora%E5%9B%BE%E7%89%87%E5%85%B1%E4%BA%AB%EF%BC%88Github+Picgo+Typora%EF%BC%89/"/>
      <url>/2023/01/05/Typora%E5%9B%BE%E7%89%87%E5%85%B1%E4%BA%AB%EF%BC%88Github+Picgo+Typora%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora图片共享（Github-Picgo-Typora）"><a href="#Typora图片共享（Github-Picgo-Typora）" class="headerlink" title="Typora图片共享（Github+Picgo+Typora）"></a>Typora图片共享（Github+Picgo+Typora）</h1><p>1、安装PicGo</p><p>右下角有安装，然后转跳到主页即可根据流程进行安装。</p><p>安装路径：<code>D:\typora\Typora</code></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415761.png" alt="image-20230104173203948"></p><h2 id="2、配置Github"><a href="#2、配置Github" class="headerlink" title="2、配置Github"></a>2、配置Github</h2><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415933.png" alt="image-20230104173406460"></p><h3 id="获得token"><a href="#获得token" class="headerlink" title="获得token"></a>获得token</h3><p>右上角头上setting &#x3D;&gt; 左下角Developer settings &#x3D;&gt; Personal access tokens (classic) &#x3D;&gt;generate new token &#x3D;&gt;</p><p>得到token</p><h2 id="3、配置Picgo"><a href="#3、配置Picgo" class="headerlink" title="3、配置Picgo"></a>3、配置Picgo</h2><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415261.png" alt="image-20230104172612597"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415656.png" alt="image-20220328081536617"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415008.png" alt="image-20230105133448055"></p><h3 id="4、测试验证即可"><a href="#4、测试验证即可" class="headerlink" title="4、测试验证即可"></a>4、测试验证即可</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415582.png" alt="image-20230104173804757"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415647.png" alt="image-20230105133305869"></p><h2 id="5、图片上传配置"><a href="#5、图片上传配置" class="headerlink" title="5、图片上传配置"></a>5、图片上传配置</h2><p>对typora进行图片配置，如下图所示</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051417484.png" alt="image-20230105141748428"></p><ul><li><p>首先在本地写typora文件时，要打开Picgo</p></li><li><p>将图片插入方式改为以上形式后，当粘贴图片进入typora时，图片会自动上传Github，且图片路径会从本地路径更改为Github建立的图床中的路径。如：上图为<code>(https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051417484.png)</code></p></li><li><p>这样，当md文件上传到Github中，图片自动引用Github图床中的图片。</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051421175.png" alt="image-20230105142120130"></p><p>Github中md文件如下：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051421539.png" alt="image-20230105142142496"></p></li><li><p>大功告成~</p></li></ul><h2 id="6、md上传hexo博客"><a href="#6、md上传hexo博客" class="headerlink" title="6、md上传hexo博客"></a>6、md上传hexo博客</h2><p>因为上述图片引用的都是GitHub图床的内容，可以直接访问，所以，在hexo上传md时，只需要将需要的md文件，复制到blog对应的md文件即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建hexo遇到的一些问题</title>
      <link href="/2023/01/04/%E5%88%9B%E5%BB%BAhexo%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/04/%E5%88%9B%E5%BB%BAhexo%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p>在<code>yarn add global hexo-cli</code>后，无法执行hexo命令（command not found）<br>在添加全局变量未果后，发现需要使用npx指令</p><ul><li><code>npx hexo init blog</code></li><li><code>cd blog</code></li><li><code>yarn add</code></li><li><code>npx hexo server</code><br>会在4000端口生成网站</li></ul><h2 id="运行问题"><a href="#运行问题" class="headerlink" title="运行问题"></a>运行问题</h2><p>但成功在4000端口运行后，发现无法载入，可能是端口已经被占用<br>*解决方法：修改端口<br><code>npx hexo s -p 5000</code><br>PS:如果找不到hexo命令，都需要提前加个npx，因为在命令行下调用，可以让项目内部安装的模块用起来更方便，npx运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在，所以系统命令也可以调用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/04/hello-world/"/>
      <url>/2023/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
