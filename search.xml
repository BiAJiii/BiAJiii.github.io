<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode(Updating...)</title>
      <link href="/2023/01/13/LeetCode-Updating/"/>
      <url>/2023/01/13/LeetCode-Updating/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode（Updating…）"><a href="#LeetCode（Updating…）" class="headerlink" title="LeetCode（Updating…）"></a>LeetCode（Updating…）</h1><h2 id="2、两数相加（考核链式）"><a href="#2、两数相加（考核链式）" class="headerlink" title="2、两数相加（考核链式）"></a>2、两数相加（考核链式）</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>__思路__：由于JS中没有内置链表，这里是自定义好的链式。其工作原理为，定义值val和next指向，而next会指向下一个node的val（对象套对象）。</p><p>1、判断l1和l2是否为其链式最后一位数，如果都是，跳出循环。注意：这里的l1和l2都是对象，所以即便他们都是空的，也不会跳出循环。所以，只有他们都为null，即为链式的结尾时，才会跳出while循环。</p><p>2、将l1和l2的node的val处理，赋给l3的node</p><p>3、l1和l2转跳到下一个node</p><p>4、当跳出循环，表示l1和l2都已经到尾部，这时判断是否有进位，有的话给l3再添加一个进位即可</p><p>5、注意：l3 new完后赋值给a3（不要对原链进行操作），这样l3可以作为链式的头部，如果直接用l3进行所有操作，最后返回l3的时候，只有链式的最后一个位或倒数第二位（有进位的情况）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val, next) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.next = (next===undefined ? null : next)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line"> //这里自定义的链式，next都指向下一个node的val</span><br><span class="line">var addTwoNumbers = function(l1, l2) &#123;</span><br><span class="line">    let a1 = l1</span><br><span class="line">    let a2 = l2</span><br><span class="line">    let carry = 0</span><br><span class="line">    let l3 = new ListNode()</span><br><span class="line">    let a3 = l3</span><br><span class="line">    //如果a1和a2中有一个没有读到null（结尾），循环继续。</span><br><span class="line">    while(a1 || a2)&#123;</span><br><span class="line">        //如果a1先结束，给后面的值都赋为0</span><br><span class="line">        const val1 = a1?a1.val:0;</span><br><span class="line">        //a2同理</span><br><span class="line">        const val2 = a2?a2.val:0;</span><br><span class="line">        const val3 = (val1 + val2 + carry) % 10</span><br><span class="line">        //判断是否有进位</span><br><span class="line">        carry = Math.floor((val1 + val2 + carry) / 10)</span><br><span class="line"></span><br><span class="line">        a3.next = new ListNode(val3)</span><br><span class="line">        //判断a是否为结尾，不是的话，读下一个node</span><br><span class="line">        if(a1) &#123;a1 = a1.next&#125;</span><br><span class="line">        if(a2) &#123;a2 = a2.next&#125;</span><br><span class="line">        a3 = a3.next</span><br><span class="line">    &#125;</span><br><span class="line">    //判断最后一位是否有进位</span><br><span class="line">    if(carry === 1)&#123;</span><br><span class="line">        a3.next = new ListNode(carry)</span><br><span class="line">    &#125;</span><br><span class="line">    return l3.next</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充上面第五点：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301141549778.png" alt="img"></p><ul><li>情况一</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = new ListNode();</span><br><span class="line">// let b = a</span><br><span class="line">a.next = new ListNode(1)</span><br><span class="line">a = a.next</span><br><span class="line">a.next = new ListNode(2)</span><br><span class="line">a = a.next</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><p>结果：<img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301111636119.png" alt="image-20230111163621543"></p><p>很明显，其实上面的代码只是不断更新a这个对象中的next属性，将最后new出来的ListNode(2)又赋给了a，最后a还是只有一个node</p><ul><li>情况二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = new ListNode();</span><br><span class="line">let b = a</span><br><span class="line">//此时，b===a</span><br><span class="line">b.next = new ListNode(1)</span><br><span class="line">b = b.next</span><br><span class="line">//b已经是一个全新的对象（即next指向的下一个node）， b!==a</span><br><span class="line">b.next = new ListNode(2)</span><br><span class="line">b = b.next</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><p>结果：<img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301111639562.png" alt="image-20230111163956390"></p><p>可以看出，这里没有直接修改链式a的属性，而是给a.next嵌套了一个新的node对象。</p><h2 id="3、无重复字符的最长字串"><a href="#3、无重复字符的最长字串" class="headerlink" title="3、无重复字符的最长字串"></a>3、无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子1：</span><br><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line">例子2：</span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>这道题想的挺久的，一开始是下面的思路（其实是读题没读对），后面才发现想的方向错了。下面的代码其实是解决一个字符串中，首尾元素重复的子字符串的最大或最小长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    let arr = Array.from(s)</span><br><span class="line">    let len = arr.length</span><br><span class="line">    let maxCount = 0</span><br><span class="line">    for(let i = 0; i &lt; len - 1; i++)&#123;</span><br><span class="line">        let j = i + 1</span><br><span class="line">        let count = 0</span><br><span class="line"></span><br><span class="line">        while(1)&#123;</span><br><span class="line">            count++</span><br><span class="line">            if(arr[i] == arr[j]) &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if(count &gt; maxCount) &#123;</span><br><span class="line">                maxCount = count</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            j++</span><br><span class="line">            if(j == len) &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来实在想不到了，就看到下面这幅图，思想很清晰，具体实现过程写在代码的注释里了。</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301121417343.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    //先将字符串转数组</span><br><span class="line">    let arr = Array.from(s)</span><br><span class="line">    //将该数组的第一位赋给新数组[]</span><br><span class="line">    let newArr = [arr[0]]</span><br><span class="line">    let len = arr.length</span><br><span class="line">    let newLen = newArr.length</span><br><span class="line">    let maxCount = 0</span><br><span class="line">    //对数组arr进行遍历</span><br><span class="line">    for(let i = 1; i &lt; len; i++)&#123;</span><br><span class="line">        //在arr的基础上对newArr进行遍历</span><br><span class="line">        for(let j = 0; j &lt; newLen; j++)&#123;</span><br><span class="line">            //判断是否新数组中是否已经存在 属于arr下标i对应的元素</span><br><span class="line">            let index = newArr.indexOf(arr[i])</span><br><span class="line">            newArr.push(arr[i])</span><br><span class="line">            //存在的话（newArr中相同的元素最多有两个，且其他元素皆无相同元素），</span><br><span class="line">            //将找到相同元素的第一个元素前面的全部数组删除。</span><br><span class="line">            if(index &gt;= 0)&#123;</span><br><span class="line">                newArr.splice(0 , index + 1)</span><br><span class="line">            &#125;</span><br><span class="line">            //如果修改后的数组长度要大于前面记录的maxCount，赋值</span><br><span class="line">            if(newArr.length &gt; maxCount)&#123;</span><br><span class="line">                maxCount = newArr.length</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、最长回文串"><a href="#5、最长回文串" class="headerlink" title="5、最长回文串"></a>5、最长回文串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>又是想了很久的题目，思路是左右指针偏移的情况。</p><p><img src="https://pic.leetcode-cn.com/533a8538f42e6a6495b87d0c054224fdaa2e6da1cd9158f3e9042894137961fc-%E6%88%AA%E5%B1%8F2019-12-06%E4%B8%8A%E5%8D%887.54.28.png" alt="截屏2019-12-06上午7.54.28.png"></p><p>本以为是很简单的情况，但越写发现情况越多，虽然最后代码写出来了，但实在是太复杂了。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestPalindrome = function(s) &#123;</span><br><span class="line">    let arr = Array.from(s)</span><br><span class="line">    let len = arr.length</span><br><span class="line">    let OutArr = [arr[0]]</span><br><span class="line">    //数组长度小于三的情况</span><br><span class="line">    if(arr.length &lt;= 2)&#123;</span><br><span class="line">        if(arr[0]==arr[1])&#123;</span><br><span class="line">            return s</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return arr[0]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组长度大于等于三的情况</span><br><span class="line">   for(let i = 1; i &lt; (len - 1); i++)&#123;</span><br><span class="line">        let j = (i - 1)//左指针</span><br><span class="line">        let k = (i + 1)//右指针</span><br><span class="line">        //如果一开始左指针和i相同，就让左指针一直左移，直到不同；</span><br><span class="line">        while((arr[j] == arr[i]))&#123;</span><br><span class="line">            //跳出循环两个条件</span><br><span class="line">            //1、左指针到达尽头</span><br><span class="line">            //2、左指针的数不等于右指针的数（这种情况是为了解决左右指针一开始就不同的字符串 如 1223 12224）</span><br><span class="line">            if(arr[k] != arr[j] &amp;&amp; (k-j) &gt;= OutArr.length)&#123;</span><br><span class="line">                OutArr = arr.slice(j,k)</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if(j == 0) break</span><br><span class="line">            if(j &gt; 0)&#123;</span><br><span class="line">                j--//左指针左移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while((arr[k] == arr[i]))&#123;</span><br><span class="line">            //这边和上面是同理的</span><br><span class="line">            if( arr[k] != arr[j])&#123;</span><br><span class="line">                //(k-j) &gt;= OutArr.length是为了保证最后一轮进入不了判断3，而影响OutArr结果</span><br><span class="line">                if(arr[j]==arr[i] &amp;&amp; (k-j) &gt;= OutArr.length)&#123;</span><br><span class="line">                    OutArr = arr.slice(j , k+1)</span><br><span class="line">                &#125;</span><br><span class="line">                if(arr[j] != arr[i] &amp;&amp; (k-j) &gt;= OutArr.length)&#123;</span><br><span class="line">                    OutArr = arr.slice(j+1 , k+1)</span><br><span class="line">                &#125;</span><br><span class="line">                k++</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if(k == (len - 1)) break</span><br><span class="line">            if(k &lt; len)&#123;</span><br><span class="line">                k++//右指针右移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断3：进入开始判断左右指针(此时左右指针之间的数字为一个或多个arr[i]，即(左指针)11111(右指针))</span><br><span class="line">        while(arr[k] == arr[j])&#123;</span><br><span class="line">            //左右指针相同，就继续扩大范围</span><br><span class="line">            if(arr[k] == arr[j])&#123;</span><br><span class="line">               let tempArr = arr.slice(j, (k + 1))</span><br><span class="line">               //判断这次循环的回文字符串是否是最大的</span><br><span class="line">               if(tempArr.length &gt;= OutArr.length) &#123;</span><br><span class="line">                    OutArr = tempArr</span><br><span class="line">                &#125;</span><br><span class="line">                //如果左右指针在不断移动的过程中仍相同，当左指针或右指针到尽头，跳出来</span><br><span class="line">                if(j == 0 || k == (len + 1))&#123;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j--</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return OutArr.join(&#x27;&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>别人写的，思路一样，这个其实就是将情况分成了两种，奇数长度（aba）和偶数长度（abba）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestPalindrome = function(s) &#123;</span><br><span class="line">        if (s.length&lt;2)&#123;</span><br><span class="line">            return s</span><br><span class="line">        &#125;</span><br><span class="line">        let res = &#x27;&#x27;</span><br><span class="line">        for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">            // 回文子串长度是奇数</span><br><span class="line">            helper(i, i)</span><br><span class="line">            // 回文子串长度是偶数</span><br><span class="line">            helper(i, i + 1) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function helper(m, n) &#123;</span><br><span class="line">            while (m &gt;= 0 &amp;&amp; n &lt; s.length &amp;&amp; s[m] == s[n]) &#123;</span><br><span class="line">                m--</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">            // 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻</span><br><span class="line">            // 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1</span><br><span class="line">            if (n - m - 1 &gt; res.length) &#123;</span><br><span class="line">                // slice也要取[m+1,n-1]这个区间 </span><br><span class="line">                res = s.slice(m + 1, n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Salvatore</span><br><span class="line">链接：https://leetcode.cn/problems/longest-palindromic-substring/solutions/697935/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="20、有效的括号"><a href="#20、有效的括号" class="headerlink" title="20、有效的括号"></a>20、有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>这道题其实没啥思路，感觉自己有点陷入一直用for循环的死胡同了，啥都想要用for解决&#x3D; &#x3D;</p><p>看到栈方法后，思路一下就清晰了，其实用栈解决这道题，会很简单。</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301141350492.png" alt="image-20230114135003411"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301141350601.png" alt="image-20230114135022537"></p><p>流程图如下：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301141409629.png" alt="image-20230114140914559"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isValid = function(s) &#123;</span><br><span class="line">    let stack = []</span><br><span class="line">    let map = new Map([</span><br><span class="line">        [&#x27;&#123;&#x27;,&#x27;&#125;&#x27;],</span><br><span class="line">        [&#x27;(&#x27;,&#x27;)&#x27;],</span><br><span class="line">        [&#x27;[&#x27;,&#x27;]&#x27;]</span><br><span class="line">    ])</span><br><span class="line">    let len = s.length</span><br><span class="line">    if(len % 2 != 0)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        //判断s[i]是否为&#123; [ (,是的话，就给栈加入</span><br><span class="line">        if(map.has(s[i]))&#123;</span><br><span class="line">            stack.push(s[i])</span><br><span class="line"></span><br><span class="line">        &#125; else if(map.get(stack[stack.length - 1]) == s[i])&#123;</span><br><span class="line">            //判断s[i]是否为&#125; ] )且对应栈里的最后一位</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length == 0? true : false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35、搜索插入位置"><a href="#35、搜索插入位置" class="headerlink" title="35、搜索插入位置"></a>35、搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实例一：</span><br><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br><span class="line">实例二：</span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br><span class="line">实例三：</span><br><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></blockquote><p>这道题其实很好想到使用二分法做，但写的时候还是遇到很多问题，其实就是边界定义搞不清楚。</p><p>用了很多if去限制边界，这样其实是很麻烦的。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">    let min = 0</span><br><span class="line">    let max = nums.length - 1</span><br><span class="line">    let index</span><br><span class="line">    let out = nums.length</span><br><span class="line">    while(min &lt;= max) &#123;</span><br><span class="line">        //取中间索引，使用以下方法而不是Math.floor((max + min) /2)，是防止溢出</span><br><span class="line">        index = min + Math.floor((max - min) /2)</span><br><span class="line">        //如果目标值比中间索引对应的值大，让最小值向中间索引右边移动一位，</span><br><span class="line">        //因为跳出循环条件是最大值小于最小值</span><br><span class="line">        //所以当目标值&gt;中间索引对应的值时，target对应的索引必然不是此时index，且必然会进入下一次循环</span><br><span class="line">        //而当目标值&lt;或=中间索引对应的值时,target对应的索引可能是此时index，所以需要用out记录此index</span><br><span class="line">        if(target &gt; nums[index])&#123;</span><br><span class="line">            min = index + 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            out = index</span><br><span class="line">            max = index - 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return out</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="69、x的平方根"><a href="#69、x的平方根" class="headerlink" title="69、x的平方根"></a>69、x的平方根</h2><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><ul><li>牛顿迭代法</li></ul><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301311540205.png" alt="image-20230131154010954"></p><p>由于是求平方根</p><p>即是<code>y = x^2 - C</code>，选择x0&#x3D;C为初始值</p><p>其中C就是y&#x3D;0时候，开方对应的要求得的值即：C&#x3D;x^2 &#x3D;&gt;  x &#x3D; C^1&#x2F;2 （x为最终求得的平方根，C为要计算的平方根），其中切点为（x0，x0^2 - C）</p><p>可以得到切线函数为 <code>y - (x0^2 + C) = 2x0(x - x0)  </code></p><p>使 y&#x3D;0 可以得到新的与x轴相交的切线的点 x1</p><p><code>x = 1/2(x0 + C/x0)</code> </p><p>将x赋给x0，这样子，x就会不断迭代，向着真正的根x逼近。</p><p>由于JS中数字是有精度的，当x0无限接近x的时候，x^2也无限接近于C，当精度到达一定数量级，x^2 &#x3D;&#x3D; C</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var mySqrt = function(x) &#123;</span><br><span class="line">    let c = x</span><br><span class="line">    let x0 = x</span><br><span class="line">    while(x0*x0 &gt; x)&#123;</span><br><span class="line">        x0 = 0.5*(x0 + c/x0) | 0</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.floor(x0)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a>70、爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><ul><li>斐波那契数列</li></ul><p>​其实这道题，可以倒着想。当在第n层的时候有f(n)种方法到达第n层，那么要想达到第n层，就只有从第n-1层爬一阶或者第n-2层爬两阶两种方法。</p><p>​那么第n-1层&#x3D;&gt;f(n-1)种方法到第n-1层；同理第n-2层&#x3D;&gt;f(n-2)种方法到第n-2层；</p><p>​这也就可以推算出，f(n) &#x3D; f(n-1) + f(n+2) 然后可以递归回到第1、2层</p><p>​到达第一层只有一种方法:f(1)&#x3D;1，到达第二层有两种方法f(2)&#x3D;2，这样倒退就可以得到f(n)了。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var climbStairs = function(n) &#123;</span><br><span class="line">    let arr = new Array(n).fill(0)</span><br><span class="line">    arr[0] = 1</span><br><span class="line">    arr[1] = 1</span><br><span class="line">    for(let i = 2 ; i &lt;= n ; i++)&#123;</span><br><span class="line">        arr[i] = arr[i-1] + arr[i-2]</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[n]</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些数据结构与算法</title>
      <link href="/2023/01/10/%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/10/%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061452280.png" alt="image-20230106145213189"></p><ul><li>存储方式：</li></ul><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061501599.png" alt="image-20230106150159499"></p><h3 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061504675.png" alt="image-20230106150422377"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061518174.png" alt="image-20230106151827638"></p><ul><li>封装实现:</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//二叉树封装</span><br><span class="line">function BST() &#123;</span><br><span class="line">    //节点保存</span><br><span class="line">    function Node(key) &#123;</span><br><span class="line">        this.key = key </span><br><span class="line">        this.left = null</span><br><span class="line">        this.right = null</span><br><span class="line">    &#125;</span><br><span class="line">    //根属性</span><br><span class="line">    this.root = null;</span><br><span class="line">    </span><br><span class="line">    BST.prototype.insert = function (key) &#123;</span><br><span class="line">        let newNode = new Node(key)</span><br><span class="line">        //判断根是否存在</span><br><span class="line">        if(this.root === null)&#123;</span><br><span class="line">            this.root = newNode</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.NodeCompare(this.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BST.prototype.NodeCompare = function (oldNode, newNode) &#123;</span><br><span class="line">        //左查找</span><br><span class="line">        if(newNode.key &lt; oldNode.key) &#123;</span><br><span class="line">            if(oldNode.left !== null) &#123;</span><br><span class="line">                this.NodeCompare(oldNode.left, newNode)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                oldNode.left = newNode</span><br><span class="line">            &#125;</span><br><span class="line">        //右查找    </span><br><span class="line">        &#125; else if( newNode.key &gt; oldNode.key ) &#123;</span><br><span class="line">            if(oldNode.right !== null) &#123;</span><br><span class="line">                this.NodeCompare(oldNode.right, newNode)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                oldNode.right = newNode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alert(&#x27;当前数值已存在&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">const bst = new BST()</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li>遍历方法：</li></ul><p>1、先序遍历</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061608249.png" alt="image-20230106160858807"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//先序遍历</span><br><span class="line">//handler用于处理遍历显示形式</span><br><span class="line">BST.prototype.preTravelsal = function(handler) &#123;</span><br><span class="line">    this.preTravelsalNode(this.root, handler)</span><br><span class="line">&#125;</span><br><span class="line">//节点遍历</span><br><span class="line">//递归调用栈（前进后出）</span><br><span class="line">BST.prototype.preTravelsalNode = function(Node, handler)&#123;</span><br><span class="line">    if(Node !== null)&#123;</span><br><span class="line">        handler(Node.key)//这个其实可以看做是当前处理的节点</span><br><span class="line">        //处理左子节点</span><br><span class="line">        this.preTravelsalNode(Node.left, handler)</span><br><span class="line">        //如果左子节点没有，处理右子节点</span><br><span class="line">        this.preTravelsalNode(Node.right, handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>测试代码：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const bst = new BST()</span><br><span class="line"></span><br><span class="line">bst.insert(3)</span><br><span class="line">bst.insert(1)</span><br><span class="line">bst.insert(4)</span><br><span class="line">bst.insert(0)</span><br><span class="line">bst.insert(2)</span><br><span class="line"></span><br><span class="line">var result = &#x27;&#x27;</span><br><span class="line">bst.preTravelsal(function (key) &#123;</span><br><span class="line">    result += key + &#x27;-&#x27;</span><br><span class="line">&#125;) </span><br><span class="line">console.log(result)</span><br><span class="line">//结果：3-1-0-2-4</span><br></pre></td></tr></table></figure></blockquote><p>2、中序遍历</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061717225.png" alt="image-20230106171729924"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//先序遍历对调一下就好</span><br><span class="line">//处理左子节点</span><br><span class="line">this.preTravelsalNode(Node.left, handler)</span><br><span class="line">//处理该节点</span><br><span class="line">handler(Node.key)</span><br><span class="line">//处理右子节点</span><br><span class="line">this.preTravelsalNode(Node.right, handler)</span><br></pre></td></tr></table></figure></blockquote><p>3、后序遍历</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301061720015.png" alt="image-20230106171937295"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同理</span><br><span class="line">//先序遍历对调一下就好</span><br><span class="line">//处理左子节点</span><br><span class="line">this.preTravelsalNode(Node.left, handler)</span><br><span class="line">//处理右子节点</span><br><span class="line">this.preTravelsalNode(Node.right, handler)</span><br><span class="line">//处理该节点</span><br><span class="line">handler(Node.key)</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li>删除节点</li></ul><p>1、查找删除的节点，找到进行下一步，未找到就return</p><p>注意：最好添加几个变量，方便后续删除</p><p>parent（删除节点的父节点） current（要删除的节点） isLeft（删除节点的左侧是否存在）</p><p>2、找到节点分为以下几个情况</p><p>​a、删除叶子点</p><p>​一：isLeft：ture ，让parent.left &#x3D; null</p><p>​二：isLeft：false ，让parent.right &#x3D; null</p><p>​b、删除有一个节点的子节点</p><p>​四种情况</p><p>​parent.left &#x3D; current.left</p><p>​parent.left &#x3D; current.right</p><p>​parent.right &#x3D; current.left</p><p>​parent.right &#x3D; current.right</p><p>​c、删除的节点有两个节点</p><p>​思路：该节点有左右两分支，其实有两种方案，如果选左边，则找到该节点左分支下最大的数字替代该节点。若选的为右边，则选择该节点右分支下最小的数字替代该节点。</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.prototype.BubbleSort = function () &#123;</span><br><span class="line">    let temp = null</span><br><span class="line">    let arr = this.array</span><br><span class="line">    for(let i = 0 ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        for(let j = 0; j &lt; arr.length - i; j++)&#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                temp = arr[j]</span><br><span class="line">                arr[j] = arr[j+1]</span><br><span class="line">                arr[j+1] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;冒泡后：&#x27; + arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091410723.png" alt="image-20230109141033549"></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​选择排序的实现思路是从未排序序列中找到最小的元素，放到已排序序列的首位，重复上述步骤，直到所有元素排序完毕。</p><p>1）假设未排序序列的第一个是最小值，记下该元素的位置，从前往后比较<br>2）若某个元素比该元素小，覆盖最小值的位置<br>3）重复第二个步骤，直到找到未排序的末尾<br>4）将未排序元素的第一个元素和最大元素交换位置<br>5）重复前面几个步骤，直到所有元素都已经排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //选择排序</span><br><span class="line">ArrayList.prototype.SelectSort = function () &#123;</span><br><span class="line">    let temp = null</span><br><span class="line">    let arr = this.array</span><br><span class="line">    let len = this.array.length</span><br><span class="line">    for( let i = 0 ; i &lt; len ; i++)&#123;</span><br><span class="line">        let index = i</span><br><span class="line">        for( let j = i+1; j &lt; len; j++)&#123;</span><br><span class="line">            if(arr[index] &gt; arr[j])&#123;</span><br><span class="line">                index = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[index]</span><br><span class="line">        arr[index] = temp</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;选择排序后：&#x27; + arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091440704.png" alt="image-20230109144042607"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091612833.png" alt="image-20230109161222605"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.prototype.InsertSort = function () &#123;</span><br><span class="line">    let Arr = this.array</span><br><span class="line">    let len = this.array.length</span><br><span class="line">    //因为每一次比较，标记index前的数组都被看做为一个整体，所以需要进行lenght-1次比较</span><br><span class="line">    for( let i = 1; i &lt; len ; i++)&#123;</span><br><span class="line">        //j对应需要比较数字的索引</span><br><span class="line">        //让j=i是为了不影响大循环中i</span><br><span class="line">        let j = i</span><br><span class="line">        //将需要比较数字记录为临时变量temp</span><br><span class="line">        let temp = Arr[i]</span><br><span class="line">        //由于插入比较是标记数字对前面的有序数组，进行从大到小的比较</span><br><span class="line">        //所以，当temp小于有序数组中对应数字，循环仍要进行</span><br><span class="line">        while(Arr[j-1] &gt; temp)&#123;</span><br><span class="line">            //由于temp小于该轮有序数组的数字，则要将该轮数字往后移，即index+1，且j--，进行下一轮比较</span><br><span class="line">            Arr[j] = Arr[j-1]</span><br><span class="line">            j--</span><br><span class="line">            //当temp与有序数组中所有数字进行比较仍未满足跳出while循环条件，即temp为有序数组中最小的数，直接在j==0的位置插入</span><br><span class="line">            if(j == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将temp插入到找到索引对应的位置中</span><br><span class="line">        Arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;插入排序：&#x27; + Arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091614746.png" alt="image-20230109161455585"></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>​希尔排序是通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。增量为：<strong>gap&#x3D;length&#x2F;2</strong></p><p>原理图示（假设数组长度为8）：</p><p>（1）gap为4</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091703499.png" alt="img"></p><p>（2）gap为2</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091704200.png" alt="img"></p><p>（3）gap为1</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091704566.png" alt="img"></p><p>其实希尔排序是基于插入排序的，只不过是希尔排序按间隔进行了分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//希尔排序</span><br><span class="line">    ArrayList.prototype.ShellSort = function() &#123;</span><br><span class="line">        let len = this.array.length</span><br><span class="line">        let arr = this.array</span><br><span class="line">        let gap = Math.floor(len/2)</span><br><span class="line">        while(gap &gt;= 1) &#123;</span><br><span class="line">            //类似插入算法那一套，但现在间隔变成了gap而不是1</span><br><span class="line">            for( let i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                let j = i</span><br><span class="line">                let temp = arr[j]</span><br><span class="line">                while(arr[j - gap] &gt; temp &amp;&amp; j &gt;= gap) &#123;</span><br><span class="line">                    arr[j] = arr[j-gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">            gap = Math.floor(gap / 2)</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#x27;希尔排序：&#x27; + arr)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效率：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091710987.png" alt="image-20230109171009853"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301091714254.png" alt="image-20230109171448025"></p><p>基本思想：</p><p>1、选定pivot中心轴</p><p>2、将大于pivot的数字放在piovt右边</p><p>3、将小于pivot的数字放在piovt右边</p><p>4、分别对左右子序列重复前前三步操作（递归）</p><p>5、当递归尽头的左右子序列长度都为1时，跳出递归</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//快速排序</span><br><span class="line">ArrayList.prototype.QuickSort = function (L ,R) &#123;</span><br><span class="line">    // L和R是为了确定一开始左和右的数如：（0，8），而left和right会随着循环变化，</span><br><span class="line">    // 如果不设定L和R，会导致栈溢出</span><br><span class="line">    // 在递归过程中，right和left是不断变化的，而L和R会保持一开始输入的数字</span><br><span class="line">    let arr = this.array</span><br><span class="line">    let left = L</span><br><span class="line">    let right = R</span><br><span class="line">    //将数组最右边的设为piovt</span><br><span class="line">    //先左指针循环，再右指针循环</span><br><span class="line">    //如果pivot为最左边</span><br><span class="line">    //则右指针先循环，左指针再循环</span><br><span class="line">    let pivot = arr[right]</span><br><span class="line">    if(left &gt;= right) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        //左指针向右遍历，遇到比pivot大的数停止</span><br><span class="line">        while(left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[left] &gt; pivot)&#123;</span><br><span class="line">            arr[right] = arr[left]</span><br><span class="line">        &#125;</span><br><span class="line">        //左指针向左遍历，遇到比pivot小的数停止</span><br><span class="line">        while(left &lt; right &amp;&amp; pivot &lt;= arr[right])&#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[right] &lt; pivot)&#123;</span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &gt;= right)&#123;</span><br><span class="line">            arr[left] = pivot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //pivot左边递归</span><br><span class="line">    this.QuickSort(L , left-1)</span><br><span class="line">    //pivot右边递归</span><br><span class="line">    this.QuickSort(left+1 ,R)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301101529051.png" alt="image-20230110152931858"></p><ul><li>X表示该数字放进了最右边的位置</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora图片共享（Github+Picgo+Typora）</title>
      <link href="/2023/01/05/Typora%E5%9B%BE%E7%89%87%E5%85%B1%E4%BA%AB%EF%BC%88Github+Picgo+Typora%EF%BC%89/"/>
      <url>/2023/01/05/Typora%E5%9B%BE%E7%89%87%E5%85%B1%E4%BA%AB%EF%BC%88Github+Picgo+Typora%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora图片共享（Github-Picgo-Typora）"><a href="#Typora图片共享（Github-Picgo-Typora）" class="headerlink" title="Typora图片共享（Github+Picgo+Typora）"></a>Typora图片共享（Github+Picgo+Typora）</h1><p>1、安装PicGo</p><p>右下角有安装，然后转跳到主页即可根据流程进行安装。</p><p>安装路径：<code>D:\typora\Typora</code></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415761.png" alt="image-20230104173203948"></p><h2 id="2、配置Github"><a href="#2、配置Github" class="headerlink" title="2、配置Github"></a>2、配置Github</h2><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415933.png" alt="image-20230104173406460"></p><h3 id="获得token"><a href="#获得token" class="headerlink" title="获得token"></a>获得token</h3><p>右上角头上setting &#x3D;&gt; 左下角Developer settings &#x3D;&gt; Personal access tokens (classic) &#x3D;&gt;generate new token &#x3D;&gt;</p><p>得到token</p><h2 id="3、配置Picgo"><a href="#3、配置Picgo" class="headerlink" title="3、配置Picgo"></a>3、配置Picgo</h2><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415261.png" alt="image-20230104172612597"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415656.png" alt="image-20220328081536617"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415008.png" alt="image-20230105133448055"></p><h3 id="4、测试验证即可"><a href="#4、测试验证即可" class="headerlink" title="4、测试验证即可"></a>4、测试验证即可</h3><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415582.png" alt="image-20230104173804757"></p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051415647.png" alt="image-20230105133305869"></p><h2 id="5、图片上传配置"><a href="#5、图片上传配置" class="headerlink" title="5、图片上传配置"></a>5、图片上传配置</h2><p>对typora进行图片配置，如下图所示</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051417484.png" alt="image-20230105141748428"></p><ul><li><p>首先在本地写typora文件时，要打开Picgo</p></li><li><p>将图片插入方式改为以上形式后，当粘贴图片进入typora时，图片会自动上传Github，且图片路径会从本地路径更改为Github建立的图床中的路径。如：上图为<code>(https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051417484.png)</code></p></li><li><p>这样，当md文件上传到Github中，图片自动引用Github图床中的图片。</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051421175.png" alt="image-20230105142120130"></p><p>Github中md文件如下：</p><p><img src="https://raw.githubusercontent.com/BiAJiii/imgsBed/main/imgs/202301051421539.png" alt="image-20230105142142496"></p></li><li><p>大功告成~</p></li></ul><h2 id="6、md上传hexo博客"><a href="#6、md上传hexo博客" class="headerlink" title="6、md上传hexo博客"></a>6、md上传hexo博客</h2><p>因为上述图片引用的都是GitHub图床的内容，可以直接访问，所以，在hexo上传md时，只需要将需要的md文件，复制到blog对应的md文件即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>创建hexo遇到的一些问题</title>
      <link href="/2023/01/04/%E5%88%9B%E5%BB%BAhexo%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/04/%E5%88%9B%E5%BB%BAhexo%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p>在<code>yarn add global hexo-cli</code>后，无法执行hexo命令（command not found）<br>在添加全局变量未果后，发现需要使用npx指令</p><ul><li><code>npx hexo init blog</code></li><li><code>cd blog</code></li><li><code>yarn add</code></li><li><code>npx hexo server</code><br>会在4000端口生成网站</li></ul><h2 id="运行问题"><a href="#运行问题" class="headerlink" title="运行问题"></a>运行问题</h2><p>但成功在4000端口运行后，发现无法载入，可能是端口已经被占用<br>*解决方法：修改端口<br><code>npx hexo s -p 5000</code><br>PS:如果找不到hexo命令，都需要提前加个npx，因为在命令行下调用，可以让项目内部安装的模块用起来更方便，npx运行的时候，会到node_modules&#x2F;.bin路径和环境变量$PATH里面，检查命令是否存在，所以系统命令也可以调用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/04/hello-world/"/>
      <url>/2023/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
